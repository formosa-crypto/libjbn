require import AllCore Int IntDiv.


from Jasmin require import JModel_x86.
import SLH64.

require JBigNumber.

(* Parameters *)
op nlimbs: int.
axiom gt0_nlimbs: 0 < nlimbs.




clone export JBigNumber.BigN
 with op nlimbs <- nlimbs
      proof gt0_nlimbs by exact gt0_nlimbs.

import BN2.


(******************************************************************************
 **                inclusion of the (parametric) extracted module            **
 ** (collected from "extracted_ths/Bn_base_extr.ec)                          **
 ******************************************************************************)

from JExtract require import Array3.

module M = {
  proc bNUTIL__cf_mask (cf:bool) : W64.t = {
    
    var mask:W64.t;
    
    mask <- (W64.of_int 0);
    (cf, mask) <- adc_64 mask (W64.of_int 0) cf;
    mask <- (- mask);
    return (mask);
  }
  proc bNUTIL__mask_cf (mask:W64.t) : bool = {
    
    var cf:bool;
    var t:W64.t;
    
    t <- (W64.of_int 0);
    (cf, t) <- sbb_64 t mask false;
    return (cf);
  }
  
  proc bNUTIL__addacc3 (b1:W64.t, b0:W64.t, a:W64.t Array3.t, k:int) : 
  W64.t Array3.t = {
    var aux: bool;
    var aux_0: W64.t;
    
    var cf:bool;
    
    (aux, aux_0) <- adc_64 a.[(k %% 3)] b0 false;
    cf <- aux;
    a.[(k %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 1) %% 3)] b1 cf;
    cf <- aux;
    a.[((k + 1) %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 2) %% 3)] (W64.of_int 0) cf;
    cf <- aux;
    a.[((k + 2) %% 3)] <- aux_0;
    return (a);
  }
  
  proc bNUTIL__addacc3x2 (x:W64.t, y:W64.t, a:W64.t Array3.t, k:int) : 
  W64.t Array3.t = {
    var aux: bool;
    var aux_0: W64.t;
    
    var b1:W64.t;
    var b0:W64.t;
    var t:W64.t;
    var cf:bool;
    var b2:W64.t;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    
    (b1, b0) <- mulu_64 x y;
    t <- b0;
    b0 <- (b0 `<<` (W8.of_int 1));
    ( _0, cf,  _1,  _2,  _3, b1) <- SHLD_64 b1 t (W8.of_int 1);
    b2 <- MOV_64 (W64.of_int 0);
    (cf, b2) <- adc_64 b2 b2 cf;
    (aux, aux_0) <- adc_64 a.[(k %% 3)] b0 false;
    cf <- aux;
    a.[(k %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 1) %% 3)] b1 cf;
    cf <- aux;
    a.[((k + 1) %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 2) %% 3)] b2 cf;
    cf <- aux;
    a.[((k + 2) %% 3)] <- aux_0;
    return (a);
  }
  
  proc __load (ap:W64.t, a:BN.t) : BN.t = {
    var aux: int;
    
    var i:int;
    var t:W64.t;
    
    i <- 0;
    while (i < nlimbs) {
      t <- (loadW64 Glob.mem (W64.to_uint (ap + (W64.of_int (8 * i)))));
      a.[i] <- t;
      i <- i + 1;
    }
    return (a);
  }
  
  proc __store (ap:W64.t, a:BN.t) : unit = {
    var aux: int;
    
    var i:int;
    var t:W64.t;
    
    i <- 0;
    while (i < nlimbs) {
      t <- a.[i];
      Glob.mem <-
      storeW64 Glob.mem (W64.to_uint (ap + (W64.of_int (8 * i)))) (t);
      i <- i + 1;
    }
    return ();
  }
  
  proc __eq_zf (a:BN.t, b:BN.t) : bool = {
    var aux: int;
    
    var zf:bool;
    var acc:W64.t;
    var i:int;
    var t:W64.t;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:W64.t;
    
    acc <- (W64.of_int 0);
    i <- 0;
    while (i < nlimbs) {
      t <- a.[i];
      t <- (t `^` b.[i]);
      acc <- (acc `|` t);
      i <- i + 1;
    }
    ( _0,  _1,  _2,  _3, zf,  _4) <- AND_64 acc acc;
    return (zf);
  }
  
  proc __eq (a:BN.t, b:BN.t) : W64.t = {
    
    var res_0:W64.t;
    var zf:bool;
    var are_equal:W64.t;
    
    zf <@ __eq_zf (a, b);
    res_0 <- (W64.of_int 0);
    are_equal <- (W64.of_int 1);
    res_0 <- (zf ? are_equal : res_0);
    return (res_0);
  }
  
  proc _eq (a:BN.t, b:BN.t) : W64.t = {
    
    var r:W64.t;
    
    r <@ __eq (a, b);
    return (r);
  }
  
  proc _eq_ (a:BN.t, b:BN.t) : W64.t = {
    
    var r:W64.t;
    
    a <- a;
    b <- b;
    r <@ _eq (a, b);
    r <- r;
    return (r);
  }
  
  proc __test0_zf (a:BN.t) : bool = {
    var aux: int;
    
    var zf:bool;
    var acc:W64.t;
    var i:int;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:W64.t;
    
    acc <- a.[0];
    i <- 1;
    while (i < nlimbs) {
      acc <- (acc `|` a.[i]);
      i <- i + 1;
    }
    ( _0,  _1,  _2,  _3, zf,  _4) <- AND_64 acc acc;
    return (zf);
  }
  
  proc __test0 (a:BN.t) : W64.t = {
    
    var res_0:W64.t;
    var is_zero:W64.t;
    var zf:bool;
    
    res_0 <- (W64.of_int 0);
    is_zero <- (W64.of_int 1);
    zf <@ __test0_zf (a);
    res_0 <- (zf ? is_zero : res_0);
    return (res_0);
  }
  
  proc _test0 (a:BN.t) : W64.t = {
    
    var r:W64.t;
    
    r <@ __test0 (a);
    return (r);
  }
  
  proc __copy (a:BN.t) : BN.t = {
    var aux: int;
    
    var r:BN.t;
    var i:int;
    var t:W64.t;
    r <- witness;
    i <- 0;
    while (i < nlimbs) {
      t <- a.[i];
      r.[i] <- t;
      i <- i + 1;
    }
    return (r);
  }
  
  proc __copy2 (a:BN.t, r:BN.t) : BN.t = {
    var aux: int;
    
    var i:int;
    var t:W64.t;
    
    i <- 0;
    while (i < nlimbs) {
      t <- a.[i];
      r.[i] <- t;
      i <- i + 1;
    }
    return (r);
  }
  
  proc __cmov (cond:bool, a:BN.t, b:BN.t) : BN.t = {
    var aux: int;
    
    var i:int;
    var t:W64.t;
    
    i <- 0;
    while (i < nlimbs) {
      t <- a.[i];
      t <- (cond ? b.[i] : t);
      a.[i] <- t;
      i <- i + 1;
    }
    return (a);
  }

  proc __cswap_mask (mask:W64.t, x:BN.t, y:BN.t) : 
  BN.t * BN.t = {
    var aux: int;
    
    var i:int;
    var tmp1:W64.t;
    
    i <- 0;
    while (i < nlimbs) {
      tmp1 <- x.[i];
      tmp1 <- (tmp1 `^` y.[i]);
      tmp1 <- (tmp1 `&` mask);
      x.[i] <- (x.[i] `^` tmp1);
      y.[i] <- (y.[i] `^` tmp1);
      i <- i + 1;
    }
    return (x, y);
  }
    
  proc __fill (x:W64.t, a:BN.t) : BN.t = {
    var aux: int;
    
    var i:int;
    
    i <- 0;
    while (i < nlimbs) {
      a.[i] <- x;
      i <- i + 1;
    }
    return (a);
  }
  
  proc __set0 (a:BN.t) : BN.t = {
    
    var t:W64.t;
    
    t <- (W64.of_int 0);
    a <@ __fill (t, a);
    return (a);
  }
  
  proc __cfill (b:bool, x:W64.t, a:BN.t) : BN.t = {
    var aux: int;
    
    var i:int;
    
    i <- 0;
    while (i < nlimbs) {
      a.[i] <- x;
      i <- i + 1;
    }
    return (a);
  }
  
  proc __set_err (_err:W64.t, a:BN.t) : BN.t = {
    var aux: int;
    
    var err:W64.t;
    var i:int;
    
    err <- _err;
    i <- 0;
    while (i < nlimbs) {
      a.[i] <- (a.[i] `|` err);
      i <- i + 1;
    }
    return (a);
  }
  
  proc __carrypropU (a:BN.t, cf:bool, k:int) : bool *
                                                            BN.t = {
    var aux_0: bool;
    var aux: int;
    var aux_1: W64.t;
    
    var i:int;
    
    i <- k;
    while (i < nlimbs) {
      (aux_0, aux_1) <- adc_64 a.[i] (W64.of_int 0) cf;
      cf <- aux_0;
      a.[i] <- aux_1;
      i <- i + 1;
    }
    return (cf, a);
  }
  
  proc __addU (a:BN.t, b:BN.t) : bool *
                                                         BN.t = {
    var aux: bool;
    var aux_1: int;
    var aux_0: W64.t;
    
    var cf:bool;
    var t:W64.t;
    var i:int;
    
    t <- b.[0];
    (aux, aux_0) <- adc_64 a.[0] t false;
    cf <- aux;
    a.[0] <- aux_0;
    i <- 1;
    while (i < nlimbs) {
      t <- b.[i];
      (aux, aux_0) <- adc_64 a.[i] t cf;
      cf <- aux;
      a.[i] <- aux_0;
      i <- i + 1;
    }
    return (cf, a);
  }
  
  proc __add (a:BN.t, b:BN.t, r:BN.t) : 
  bool * BN.t = {
    var aux: int;
    
    var cf:bool;
    var t:W64.t;
    var i:int;
    
    t <- a.[0];
    (cf, t) <- adc_64 t b.[0] false;
    r.[0] <- t;
    i <- 1;
    while (i < nlimbs) {
      t <- a.[i];
      (cf, t) <- adc_64 t b.[i] cf;
      r.[i] <- t;
      i <- i + 1;
    }
    return (cf, r);
  }
  
  proc _addU (a:BN.t, b:BN.t) : bool *
                                                        BN.t = {
    
    var cf:bool;
    
    (cf, a) <@ __addU (a, b);
    return (cf, a);
  }
  
  proc _add (a:BN.t, b:BN.t, r:BN.t) : 
  bool * BN.t = {
    
    var cf:bool;
    
    (cf, r) <@ __add (a, b, r);
    return (cf, r);
  }
  
  proc __subU (a:BN.t, b:BN.t) : bool *
                                                         BN.t = {
    var aux: bool;
    var aux_1: int;
    var aux_0: W64.t;
    
    var cf:bool;
    var t:W64.t;
    var i:int;
    
    t <- b.[0];
    (aux, aux_0) <- sbb_64 a.[0] t false;
    cf <- aux;
    a.[0] <- aux_0;
    i <- 1;
    while (i < nlimbs) {
      t <- b.[i];
      (aux, aux_0) <- sbb_64 a.[i] t cf;
      cf <- aux;
      a.[i] <- aux_0;
      i <- i + 1;
    }
    return (cf, a);
  }
  
  proc __sub (a:BN.t, b:BN.t, r:BN.t) : 
  bool * BN.t = {
    var aux: int;
    
    var cf:bool;
    var t:W64.t;
    var i:int;
    
    t <- a.[0];
    (cf, t) <- sbb_64 t b.[0] false;
    r.[0] <- t;
    i <- 1;
    while (i < nlimbs) {
      t <- a.[i];
      (cf, t) <- sbb_64 t a.[i] cf;
      r.[i] <- t;
      i <- i + 1;
    }
    return (cf, r);
  }
  
  proc __lt_cf (a:BN.t, b:BN.t) : bool = {
    var aux: int;
    
    var cf:bool;
    var t:W64.t;
    var i:int;
    
    t <- a.[0];
    (cf, t) <- sbb_64 t b.[0] false;
    i <- 1;
    while (i < nlimbs) {
      t <- a.[i];
      (cf, t) <- sbb_64 t b.[i] cf;
      i <- i + 1;
    }
    return (cf);
  }
  
  proc __negU (a:BN.t) : BN.t = {
    var aux: int;
    
    var t:W64.t;
    var cf:bool;
    var i:int;
    
    t <- (W64.of_int 0);
    (cf, t) <- sbb_64 t a.[0] false;
    a.[0] <- t;
    i <- 1;
    while (i < nlimbs) {
      t <- (W64.of_int 0);
      (cf, t) <- sbb_64 t a.[i] cf;
      a.[i] <- t;
      i <- i + 1;
    }
    return (a);
  }
  
  proc __neg (a:BN.t, r:BN.t) : BN.t = {
    var aux: int;
    
    var t:W64.t;
    var cf:bool;
    var i:int;
    
    t <- (W64.of_int 0);
    (cf, t) <- sbb_64 t a.[0] false;
    r.[0] <- t;
    i <- 1;
    while (i < nlimbs) {
      t <- (W64.of_int 0);
      (cf, t) <- sbb_64 t a.[i] cf;
      r.[i] <- t;
      i <- i + 1;
    }
    return (r);
  }
  
  proc _subU (a:BN.t, b:BN.t) : bool *
                                                        BN.t = {
    
    var cf:bool;
    
    (cf, a) <@ __subU (a, b);
    return (cf, a);
  }
  
  proc _sub (a:BN.t, b:BN.t, r:BN.t) : 
  bool * BN.t = {
    
    var cf:bool;
    
    (cf, r) <@ __sub (a, b, r);
    return (cf, r);
  }
  
  proc __rnd (a:BN.t) : BN.t = {
(* (for now...)
    var aux: W8.t Array88.t;
    a <- a;
    aux <@ SC.randombytes_88 ((Array88.init (fun i => get8
                              (WArray88.init64 (fun i => (a).[i])) i)));
    a <-
    (A.init (fun i => get64 (WArray88.init8 (fun i => (aux).[i])) i));
    a <- a;
*)
    return (a);
  }
  
  proc __rsample (a:BN.t, bnd:BN.t) : BN.t = {
    
    var cf:bool;
    
    a <@ __rnd (a);
    cf <@ __lt_cf (a, bnd);
    while ((! cf)) {
      a <@ __rnd (a);
      cf <@ __lt_cf (a, bnd);
    }
    return (a);
  }
  
  proc __subU_signabs (a:BN.t, b:BN.t) : bool *
                                                                 BN.t = {
    
    var cf:bool;
    var tmp:BN.t;
    var  _0:bool;
    tmp <- witness;
    ( _0, tmp) <@ __sub (b, a, tmp);
    (cf, a) <@ __subU (a, b);
    a <@ __cmov (cf, a, tmp);
    return (cf, a);
  }
  
  proc __cnegU (cond:W64.t, a:BN.t) : BN.t = {
    
    var x:BN.t;
    var cf:bool;
    x <- witness;
    x <@ __neg (a, x);
    cf <@ bNUTIL__mask_cf (cond);
    a <@ __cmov (cf, a, x);
    return (a);
  }
  
  proc __caddU (cf:bool, x:BN.t, y:BN.t) : BN.t = {
    var aux: int;
    
    var _tmp:BN.t;
    var t0:W64.t;
    var i:int;
    var t:W64.t;
    var tmp:BN.t;
    var  _0:bool;
    _tmp <- witness;
    tmp <- witness;
    _tmp <@ __copy (y);
    t0 <- (W64.of_int 0);
    i <- 0;
    while (i < nlimbs) {
      t <- _tmp.[i];
      t <- ((! cf) ? t0 : t);
      _tmp.[i] <- t;
      i <- i + 1;
    }
    tmp <- _tmp;
    ( _0, x) <@ __addU (x, tmp);
    return (x);
  }
  
  proc __muln_innerloop (k:int, istart:int, iend:int, a:BN.t,
                           b:BN.t, x:W64.t Array3.t) : W64.t Array3.t = {
    var aux: int;
    
    var i:int;
    var j:int;
    var t0:W64.t;
    var t1:W64.t;
    
    aux <- iend;
    i <- istart;
    while (i < aux) {
      j <- (k - i);
      t0 <- a.[i];
      (t1, t0) <- mulu_64 t0 b.[j];
      x <@ bNUTIL__addacc3 (t1, t0, x, k);
      i <- i + 1;
    }
    return (x);
  }
  
  proc __muln (a:BN.t, b:BN.t, r:BN2.t) : 
  BN2.t = {
    var aux: int;
    
    var t0:W64.t;
    var t1:W64.t;
    var x:W64.t Array3.t;
    var k:int;
    x <- witness;
    t0 <- a.[0];
    (t1, t0) <- mulu_64 t0 b.[0];
    r.[0] <- t0;
    x.[1] <- t1;
    x.[2] <- (W64.of_int 0);
    x.[0] <- (W64.of_int 0);
    k <- 1;
    while (k < nlimbs) {
      x <@ __muln_innerloop (k, 0, (k + 1), a, b, x);
      t0 <- x.[(k %% 3)];
      x.[(k %% 3)] <- (W64.of_int 0);
      r.[k] <- t0;
      k <- k + 1;
    }
    aux <- ((2 * nlimbs) - 1);
    k <- nlimbs;
    while (k < aux) {
      x <@ __muln_innerloop (k, ((k - nlimbs) + 1), nlimbs, a, b, x);
      t0 <- x.[(k %% 3)];
      x.[(k %% 3)] <- (W64.of_int 0);
      r.[k] <- t0;
      k <- k + 1;
    }
    r.[((2 * nlimbs) - 1)] <- x.[(((2 * nlimbs) - 1) %% 3)];
    return (r);
  }
  
  proc _muln (a:BN.t, b:BN.t, r:BN2.t) : 
  BN2.t = {
    
    
    
    r <@ __muln (a, b, r);
    return (r);
  }
  
  proc __sqrn_innerloop (k:int, istart:int, iend:int, a:BN.t,
                           x:W64.t Array3.t) : W64.t Array3.t = {
    var aux: int;
    
    var i:int;
    var j:int;
    var ti:W64.t;
    var tj:W64.t;
    
    aux <- iend;
    i <- istart;
    while (i < aux) {
      j <- (k - i);
      ti <- a.[i];
      tj <- a.[j];
      x <@ bNUTIL__addacc3x2 (ti, tj, x, k);
      i <- i + 1;
    }
    return (x);
  }
  
  proc __sqrn (a:BN.t, r:BN2.t) : BN2.t = {
    var aux: int;
    
    var t0:W64.t;
    var t1:W64.t;
    var x:W64.t Array3.t;
    var k:int;
    x <- witness;
    t0 <- a.[0];
    (t1, t0) <- mulu_64 t0 t0;
    r.[0] <- t0;
    x.[1] <- t1;
    x.[2] <- (W64.of_int 0);
    x.[0] <- (W64.of_int 0);
    k <- 1;
    while (k < nlimbs) {
      x <@ __sqrn_innerloop (k, 0, ((k + 1) %/ 2), a, x);
      if (((k %% 2) = 0)) {
        t0 <- a.[(k %/ 2)];
        (t1, t0) <- mulu_64 t0 t0;
        x <@ bNUTIL__addacc3 (t1, t0, x, k);
      } else {
        
      }
      t0 <- x.[(k %% 3)];
      x.[(k %% 3)] <- (W64.of_int 0);
      r.[k] <- t0;
      k <- k + 1;
    }
    aux <- ((2 * nlimbs) - 1);
    k <- nlimbs;
    while (k < aux) {
      x <@ __sqrn_innerloop (k, ((k - nlimbs) + 1), ((k + 1) %/ 2), a, x);
      if (((k %% 2) = 0)) {
        t0 <- a.[(k %/ 2)];
        (t1, t0) <- mulu_64 t0 t0;
        x <@ bNUTIL__addacc3 (t1, t0, x, k);
      } else {
        
      }
      t0 <- x.[(k %% 3)];
      x.[(k %% 3)] <- (W64.of_int 0);
      r.[k] <- t0;
      k <- k + 1;
    }
    r.[((2 * nlimbs) - 1)] <- x.[(((2 * nlimbs) - 1) %% 3)];
    return (r);
  }
  
  proc _sqrn (a:BN.t, r:BN2.t) : BN2.t = {
    
    
    
    r <@ __sqrn (a, r);
    return (r);
  }
  
  proc __cminusP (lastbit:W64.t, x:BN.t, mP:BN.t) : 
  BN.t = {
    
    var _tmp:BN.t;
    var tmp:BN.t;
    var _cf:bool;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:bool;
    var  _5:W64.t;
    _tmp <- witness;
    tmp <- witness;
    _tmp <@ __copy (x);
    tmp <- _tmp;
    (_cf, tmp) <@ __addU (tmp, mP);
    ( _0, lastbit) <- adc_64 lastbit (W64.of_int 0) _cf;
    ( _1, _cf,  _2,  _3,  _4,  _5) <- NEG_64 lastbit;
    x <@ __cmov (_cf, x, tmp);
    return (x);
  }
  
  proc __mont_redM (a:BN2.t, r:BN.t,
                      _P:BN.t, _mP:BN.t, _U0:W64.t) : 
  BN.t = {
    var aux_0: bool;
    var aux: int;
    var aux_1: W64.t;
    
    var x:W64.t Array3.t;
    var p:BN.t;
    var k:int;
    var zero:W64.t;
    var t0:W64.t;
    var t1:W64.t;
    var lastbit:W64.t;
    var cf:bool;
    var mP:BN.t;
    var  _0:W64.t;
    var  _1:bool;
    p <- witness;
    mP <- witness;
    x <- witness;
    x.[0] <- (W64.of_int 0);
    x.[1] <- (W64.of_int 0);
    x.[2] <- (W64.of_int 0);
    k <- 0;
    while (k < nlimbs) {
      p <- _P;
      x <@ __muln_innerloop (k, 0, k, r, p, x);
      zero <- (W64.of_int 0);
      t0 <- a.[k];
      x <@ bNUTIL__addacc3 (zero, t0, x, k);
      t0 <- x.[(k %% 3)];
      ( _0, t0) <- mulu_64 t0 _U0;
      r.[k] <- t0;
      (t1, t0) <- mulu_64 t0 _P.[0];
      x <@ bNUTIL__addacc3 (t1, t0, x, k);
      k <- k + 1;
    }
    aux <- ((2 * nlimbs) - 1);
    k <- nlimbs;
    while (k < aux) {
      p <- _P;
      x <@ __muln_innerloop (k, ((k - nlimbs) + 1), nlimbs, r, p, x);
      zero <- (W64.of_int 0);
      t0 <- a.[k];
      x <@ bNUTIL__addacc3 (zero, t0, x, k);
      t0 <- x.[(k %% 3)];
      r.[(k - nlimbs)] <- t0;
      x.[(k %% 3)] <- (W64.of_int 0);
      k <- k + 1;
    }
    lastbit <- (W64.of_int 0);
    (aux_0, aux_1) <- adc_64 x.[(((2 * nlimbs) - 1) %% 3)] a.[((2 * nlimbs) - 1)]
    false;
    cf <- aux_0;
    x.[(((2 * nlimbs) - 1) %% 3)] <- aux_1;
    ( _1, lastbit) <- adc_64 lastbit (W64.of_int 0) cf;
    r.[(nlimbs - 1)] <- x.[(((2 * nlimbs) - 1) %% 3)];
    mP <- _mP;
    r <@ __cminusP (lastbit, r, mP);
    return (r);
  }
  
  proc __pack2 (lo:BN.t, hi:BN.t, r:BN2.t) : 
  BN2.t = {
    var aux: int;
    
    var i:int;
    var t:W64.t;
    
    i <- 0;
    while (i < nlimbs) {
      t <- lo.[i];
      r.[i] <- t;
      i <- i + 1;
    }
    i <- 0;
    while (i < nlimbs) {
      t <- hi.[i];
      r.[(nlimbs + i)] <- t;
      i <- i + 1;
    }
    return (r);
  }
}.

(******************************************************************************
 **               Library LEMMAS                                             **
 **                                                                          **
 ******************************************************************************)


(** LOSSLESS lemmas *)
lemma bNUTIL__cf_mask_ll: islossless M.bNUTIL__cf_mask
by islossless.

lemma __load_ll: islossless M.__load.
proof.
proc; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __store_ll: islossless M.__store.
proof.
proc; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __eq_zf_ll: islossless M.__eq_zf.
proof.
proc; wp; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __eq_ll: islossless M.__eq.
proof. by proc; wp; call __eq_zf_ll. qed.

lemma _eq_ll: islossless M._eq.
proof. by proc; call __eq_ll. qed.

lemma _eq__ll: islossless M._eq_.
proof. by proc; wp; call _eq_ll; auto. qed.

lemma __test0_zf_ll: islossless M.__test0_zf.
proof.
proc; wp; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __test0_ll: islossless M.__test0.
proof. by proc; wp; call __test0_zf_ll; auto. qed.

lemma _test0_ll: islossless M._test0.
proof. by proc; call __test0_ll. qed.

lemma __copy_ll: islossless M.__copy.
proof.
proc; wp; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __copy2_ll: islossless M.__copy2.
proof.
proc; wp; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __cmov_ll: islossless M.__cmov.
proof.
proc; wp; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __set0_ll: islossless M.__set0.
proof.
proc.
admitted (* while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.*).

(*
lemma __add1U_ll: islossless M.__add1U.
proof.
proc; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.
*)

lemma __addU_ll: islossless M.__addU.
proof.
proc; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma _addU_ll: islossless M._addU.
proof. by proc; call __addU_ll. qed.

lemma __subU_ll: islossless M.__subU.
proof.
proc; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma __lt_cf_ll: islossless M.__lt_cf.
proof.
proc; while (0 <= i <= nlimbs) (nlimbs - i).
 by move=> z; auto => /> &m /#.
by auto => />; smt(gt0_nlimbs).
qed.

lemma _subU_ll: islossless M._subU.
proof. by proc; call __subU_ll. qed.


(* Correctness lemmas *)
import JBigNumber.
hoare __eq_zf_h _a _b:
 M.__eq_zf: a=_a /\ b=_b ==> res =  (_a=_b).
proof.
proc; simplify. 
wp; while ( #pre /\ 0 <= i <= nlimbs /\ ((acc = W64.zero) <=> (bnk i a = bnk i b))).
 wp; skip => /> &hr Hi1 Hi2 [HL HR] Hi3.
 split; first smt().
 split.
  rewrite W64_orw_eq0 W64_xorw_eq0; move => [E1 E2].
  by rewrite !bnkS 1..2:/# /= E2 (HL E1) /#.
 move => /(BN.bnkS_eq _ _ _ Hi1) [E1 E2].
 by rewrite W64_orw_eq0 (HR E2) E1.
wp; skip => />; split; first smt(gt0_nlimbs BN.bnk0).
move=> acc i ???; rewrite (_:i=nlimbs) 1:/#.
move=> [H1 H2].
rewrite /AND_64 /rflags_of_bwop_w /flags_w /rflags_of_bwop /ZF_of /=.
by case: (acc = W64.zero) => C; smt(BN.bn_inj).
qed.

phoare __eq_zf_ph _a _b:
 [M.__eq_zf: a=_a /\ b=_b ==> res = (_a=_b)] = 1%r.
proof. by conseq __eq_zf_ll (__eq_zf_h _a _b). qed.

hoare __eq_h _a _b:
 M.__eq: a=_a /\ b=_b ==> to_uint res =  b2i (_a=_b).
proof.
proc; wp; call (__eq_zf_h _a _b); skip => />.
by case: (_a=_b) => C /#.
qed.

phoare __eq_ph _a _b:
 [M.__eq: a=_a /\ b=_b ==> to_uint res =  b2i (_a=_b)] = 1%r.
proof. by conseq __eq_ll (__eq_h _a _b). qed.

hoare _eq_h _a _b:
 M._eq: a=_a /\ b=_b ==> to_uint res = b2i (_a=_b).
proof. by proc; ecall (__eq_h a b). qed.

phoare _eq_ph _a _b:
 [M._eq: a=_a /\ b=_b ==> to_uint res = b2i (_a=_b)] = 1%r.
proof. by conseq _eq_ll (_eq_h _a _b). qed.
 
hoare _eq__h _a _b:
 M._eq_: _a=a /\ _b=b ==> to_uint res = b2i (_a=_b).
proof. by proc; wp; ecall (_eq_h a b); auto. qed.
 
phoare _eq__ph _a _b:
 [M._eq_: _a=a /\ _b=b ==> to_uint res = b2i (_a=_b) ] = 1%r.
proof. by conseq _eq__ll (_eq__h _a _b). qed.

hoare __test0_zf_h _a:
 M.__test0_zf: a=_a ==> res = (bn _a=0).
proof.
proc.
wp; while ( #pre /\ 0 <= i <= nlimbs /\ ((acc = W64.zero) <=> (bnk i a = 0))).
 wp; skip; progress; first 2 smt().
  move: H3; rewrite W64_orw_eq0 => [[E1 E2]].
  by rewrite bnkS 1:/# /= E2 to_uint0 /= -H1 E1.
 move: (BN.bnkS_eq0 _ _ H H3) => {H3} [H31 H32].
 by rewrite W64_orw_eq0 H1 H32 /= to_uint_eq /#.
wp; skip => />; progress.
   smt(gt0_nlimbs).
  by rewrite bnk1 /= H to_uint0.
 by move: H; rewrite bnk1 /= to_uint_eq /=.
move: H2; rewrite (_:i0=nlimbs) 1:/# => <-.
by rewrite /AND_64 /#.
qed.

phoare __test0_zf_ph _a:
 [M.__test0_zf: a=_a ==> res = (bn _a=0)] = 1%r.
proof. by conseq __test0_zf_ll (__test0_zf_h _a). qed.

hoare __test0_h _a:
 M.__test0: a=_a ==> to_uint res = b2i (bn _a=0).
proof.
proc; wp; call (__test0_zf_h _a); auto => />.
case (bnk nlimbs _a = 0) => _; smt().
qed.

phoare __test0_ph _a:
 [M.__test0: a=_a ==> to_uint res = b2i (bn _a=0)] = 1%r.
proof. by conseq __test0_ll (__test0_h _a). qed.

hoare _test0_h _a:
 M._test0: a=_a ==> to_uint res = b2i (bn _a=0).
proof. by proc; ecall (__test0_h a). qed.
 
phoare _test0_ph _a:
 [M._test0: a=_a ==> to_uint res = b2i (bn _a=0)] = 1%r.
proof. by conseq _test0_ll (_test0_h _a). qed.

hoare __copy_h _a:
 M.__copy: a=_a ==> res = _a.
proof.
proc; while (0 <= i <= nlimbs /\ _a = a /\ (forall j, 0 <= j < i => r.[j] = _a.[j])).
 by wp; skip; progress; [smt() | smt() | rewrite get_setE => /#]. 
wp; skip; progress; first 2 smt(gt0_nlimbs).  
by rewrite tP /#.
qed.

phoare __copy_ph _a:
 [M.__copy: a=_a ==> res = _a] = 1%r.
proof. by conseq __copy_ll (__copy_h _a). qed.

hoare __copy2_h _a:
 M.__copy2: a=_a ==> res = _a.
proof.
proc; while (0 <= i <= nlimbs /\ _a = a /\ (forall j, 0 <= j < i => r.[j] = _a.[j])).
 by wp; skip; progress; [smt() | smt() | rewrite get_setE => /#]. 
wp; skip; progress; first 2 smt(gt0_nlimbs).  
by rewrite tP /#.
qed.

phoare __copy2_ph _a:
 [M.__copy2: a=_a ==> res = _a] = 1%r.
proof. by conseq __copy2_ll (__copy2_h _a). qed.

hoare __cmov_h _cond _a _b:
 M.__cmov: cond=_cond /\ a=_a /\ b=_b
              ==> res = if _cond then _b else _a.
proof.
proc => //=. 
while (0 <= i <= nlimbs /\ _cond = cond /\ _b = b /\
       (forall j, i <= j < nlimbs => a.[j] = _a.[j]) /\
       forall j, 0 <= j < i => a.[j] = if _cond then _b.[j] else _a.[j]).
 wp; skip => /> &hr *; split; first smt().
 split.
  move=> j Hj1 Hj2; rewrite get_setE 1:/#.
  by rewrite ifF 1:/# /#.
 by move=> j Hj1 Hj2; rewrite get_setE 1:/# /#.
wp; skip => />. split; first smt(gt0_nlimbs).
move=> a i ???; rewrite (:i=nlimbs) 1:/# => H1 H2.
by rewrite tP /#.
qed.

phoare __cmov_ph _cond _a _b:
 [M.__cmov: cond=_cond /\ a=_a /\ b=_b
              ==> res = if _cond then _b else _a] = 1%r.
proof. by conseq __cmov_ll (__cmov_h _cond _a _b). qed.

hoare __set0_h:
 M.__set0 : true ==> bn res = 0.
proof.
proc.
admitted(*
while (bnk i a = 0 /\ 0 <= i <= nlimbs /\ to_uint t = 0).
 auto => /> *.
 by rewrite bnkS 1:/# /= get_setE 1:/# bnk_setO /#.
by auto => /> &m; smt(bnk0 gt0_nlimbs).
qed.
*).

phoare __set0_ph:
 [M.__set0 : true ==> bn res = 0] = 1%r.
proof. by conseq __set0_ll __set0_h. qed.

(*
hoare __add1U_h _a _b:
 M.__add1U :
 a=_a /\ b=_b
 ==> withcarry res = bn _a + to_uint _b.
proof.
have Hlimbs:= gt0_nlimbs; proc; simplify.
while (1 <= i <= nlimbs /\ _b = b /\
       (forall j, i <= j < nlimbs => a.[j] = _a.[j]) /\
       bnk_withcarry i (cf, a) = bnk i _a + to_uint b).
 wp; skip => &hr [[[Hi1 Hi2]]] /> Ha H Hc.
 split; [smt() | split].
  by move=> j Hj1 Hj2; rewrite get_setE 1:/# ifF /#.
 rewrite -/(bnk_addc i{hr} cf{hr} a{hr} W64.zero).
 rewrite bnk_withcarryS 1:/# bnkS 1:/# /=. 
 by rewrite -addzA -H /#.
auto => />; split.
 split; first smt().
 split.
  by move=> j Hj1 Hj2; rewrite get_setE /#.
 rewrite -/(bnk_addc 0 false _a _b).
 rewrite {1}(:1=0+1) 1:/# bnk_withcarryS 1:/# expr0 bnk1 /=.
 by rewrite /bnk_withcarry /= b2i0 bnk0 /=.
by move=> a cf i ??? _; rewrite (:i=nlimbs) 1:/#.
qed.
*)

hoare __addU_h _a _b:
 M.__addU : 
 a=_a /\ b=_b ==> bn_withcarry res = bn _a + bn _b.
proof.
have Hlimbs:= gt0_nlimbs; proc; simplify.
while (1 <= i <= nlimbs /\ _b = b /\
       (forall j, i <= j < nlimbs => a.[j] = _a.[j]) /\
       bnk_withcarry i (cf, a) = bnk i _a + bnk i _b).
 wp; skip => &hr [[[Hi1 Hi2]]] /> Ha H Hc.
 split; [smt() | split].
  by move=> j Hj1 Hj2; rewrite get_setE 1:/# ifF /#.
 rewrite -/(bnk_addc i{hr} cf{hr} a{hr} b{hr}.[i{hr}]).
 rewrite bnk_withcarryS 1:/# !bnkS 1..2:/# /=.
 rewrite Ha 1:/#. 
 by ring H.
auto => />; split.
 split; first smt().
 split.
  by move=> j Hj1 Hj2; rewrite get_setE /#.
 rewrite -/(bnk_addc 0 false _a _b.[0]).
 rewrite {1}(:1=0+1) 1:/# bnk_withcarryS 1:/# expr0 !bnk1 /=.
 by rewrite /bnk_withcarry /= b2i0 bnk0 /=.
by move=> a cf i ??? _; rewrite (:i=nlimbs) 1:/#.
qed.

phoare __addU_ph _a _b:
 [ M.__addU : 
   a=_a /\ b=_b 
   ==> bn_withcarry res = bn _a + bn _b] = 1%r.
proof. by conseq __addU_ll (__addU_h _a _b). qed.

hoare _addU_h _a _b:
 M._addU : 
 a=_a /\ b=_b
 ==> bn_withcarry res = bn _a + bn _b.
proof. by proc; ecall (__addU_h a b). qed.

phoare _addU_ph _a _b:
 [ M._addU : 
   a=_a /\ b=_b 
   ==> bn_withcarry res = bn _a + bn _b] = 1%r.
proof. by conseq _addU_ll (_addU_h _a _b). qed.




hoare __muln_h _a _b:
 M.__muln :
  a=_a /\ b=_b ==> BN2.bn res = bn _a * bn _b.
admitted.

phoare __muln_ph _a _b:
 [ M.__muln
 : a=_a /\ b=_b ==> bn res = bn _a * bn _b
 ] = 1%r.
admitted.
