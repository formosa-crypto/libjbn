require import AllCore Int IntDiv.


from Jasmin require import JModel_x86.
import SLH64.

require JBigNumber Bn_base.

(* Parameters *)
op nlimbs: int.
axiom gt0_nlimbs: 0 < nlimbs.
op nlimbsexp: int.
axiom gt0_nlimbsexp: 0 < nlimbsexp.

clone JBigNumber.BN as BNexp
 with op nlimbs <- nlimbsexp
      proof gt0_nlimbs by exact gt0_nlimbsexp.

import BNexp.A.

clone import JBigNumber.BigN
 with op nlimbs <- nlimbs
      proof gt0_nlimbs by exact gt0_nlimbs.


op glob_exp0: BN.t.
op mul_op: BN.t -> BN.t -> BN.t.

clone Bn_base as BNB
 with op nlimbs <- nlimbs,
      theory BigN <- BigN
      proof gt0_nlimbs by exact gt0_nlimbs.

(******************************************************************************
 **                inclusion of the (parametric) extracted module            **
 ** (collected from "extracted_ths/Bn_exp_extr.ec)                           **
 ******************************************************************************)

module type MParam = {
  proc fun_mulU (r:BN.t, a:BN.t) : BN.t
  proc fun_sqrU (r:BN.t) : BN.t
}.

module BN_M = BNB.M. 

module M(P: MParam) = {
  proc _expm_noct (a:BN.t, b:BNexp.t, r:BN.t) : 
  BN.t = {
    var aux: int;
    
    var _b:BNexp.t;
    var exp0:BN.t;
    var _x:BN.t;
    var x:BN.t;
    var j:int;
    var t:W64.t;
    var _k:W64.t;
    var zf:bool;
    var cf:bool;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:bool;
    var  _5:bool;
    var  _6:bool;
    _b <- witness;
    _x <- witness;
    exp0 <- witness;
    x <- witness;
    _b <- b;
    exp0 <- glob_exp0;
    r <@ BN_M.__copy2 (exp0, r);
    x <- _x;
    x <@ BN_M.__copy2 (a, x);
    _x <- x;
    j <- 0;
    while (j < nlimbsexp) {
      b <- _b;
      t <- b.[j];
      _k <- (W64.of_int 64);
      ( _0, cf,  _1,  _2,  _3, t) <- SHR_64 t (W8.of_int 1);
      x <- _x;
      if (cf) {
        r <- r;
        x <- x;
        r <@ P.fun_mulU (r, x);
      } else {
        
      }
      x <- x;
      x <@ P.fun_sqrU (x);
      _x <- x;
      ( _4,  _5,  _6, zf, _k) <- DEC_64 _k;
      while ((! zf)) {
        ( _0, cf,  _1,  _2,  _3, t) <- SHR_64 t (W8.of_int 1);
        x <- _x;
        if (cf) {
          r <- r;
          x <- x;
          r <@ P.fun_mulU (r, x);
        } else {
          
        }
        x <- x;
        x <@ P.fun_sqrU (x);
        _x <- x;
        ( _4,  _5,  _6, zf, _k) <- DEC_64 _k;
      }
      j <- j + 1;
    }
    return (r);
  }
  
  proc _expm (a:BN.t, b:BNexp.t, x0:BN.t) : 
  BN.t = {
    var aux: int;
    
    var _b:BNexp.t;
    var exp0:BN.t;
    var _x1:BN.t;
    var x1:BN.t;
    var j:int;
    var t:W64.t;
    var _k:W64.t;
    var zf:bool;
    var cf:bool;
    var _t:W64.t;
    var mask:W64.t;
    var _mask:W64.t;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:bool;
    var  _5:bool;
    var  _6:bool;
    _b <- witness;
    _x1 <- witness;
    exp0 <- witness;
    x1 <- witness;
    _b <- b;
    exp0 <- glob_exp0;
    x0 <@ BN_M.__copy2 (exp0, x0);
    x1 <- _x1;
    x1 <@ BN_M.__copy2 (a, x1);
    aux <- (- 1);
    j <- (nlimbsexp - 1);
    while (aux < j) {
      b <- _b;
      t <- b.[j];
      _k <- (W64.of_int 64);
      ( _0, cf,  _1,  _2,  _3, t) <- SHL_64 t (W8.of_int 1);
      _t <- t;
      mask <@ BN_M.bNUTIL__cf_mask (cf);
      (x0, x1) <@ BN_M.__cswap_mask (mask, x0, x1);
      _mask <- mask;
      x0 <- x0;
      x1 <- x1;
      x1 <@ P.fun_mulU (x1, x0);
      x0 <- x0;
      x0 <@ P.fun_sqrU (x0);
      mask <- _mask;
      (x0, x1) <@ BN_M.__cswap_mask (mask, x0, x1);
      t <- _t;
      ( _4,  _5,  _6, zf, _k) <- DEC_64 _k;
      while ((! zf)) {
        ( _0, cf,  _1,  _2,  _3, t) <- SHL_64 t (W8.of_int 1);
        _t <- t;
        mask <@ BN_M.bNUTIL__cf_mask (cf);
        (x0, x1) <@ BN_M.__cswap_mask (mask, x0, x1);
        _mask <- mask;
        x0 <- x0;
        x1 <- x1;
        x1 <@ P.fun_mulU (x1, x0);
        x0 <- x0;
        x0 <@ P.fun_sqrU (x0);
        mask <- _mask;
        (x0, x1) <@ BN_M.__cswap_mask (mask, x0, x1);
        t <- _t;
        ( _4,  _5,  _6, zf, _k) <- DEC_64 _k;
      }
      j <- j - 1;
    }
    return (x0);
  }
}.

(******************************************************************************
 **               Library LEMMAS                                             **
 **                                                                          **
 ******************************************************************************)


section.

declare module P <: MParam.

declare axiom sqr_mul_eq:
 equiv [ P.fun_sqrU ~ P.fun_mulU
       : ={r} /\ a{2}=r{2} ==> ={res} ].

declare axiom mul_sem_ph _x _y:
 phoare [ P.fun_mulU
        : r=_x /\ a=_y ==> res = mul_op _x _y
        ] = 1%r.

local lemma mulU_ll: islossless P.fun_mulU.
proof.
proc*; exlim r => _x; exlim a => _y.
by call (mul_sem_ph _x _y).
qed.

local lemma sqrU_ll: islossless P.fun_sqrU.
proof.
conseq sqr_mul_eq mulU_ll => /> &1.
by exists (arg{1},arg{1}).
qed.

lemma _expm_noct_ll: islossless M(P)._expm_noct.
proof.
proc; wp.
seq 7: (true).
 admit.
exlim exp0 => _exp0.
call (BNB.__copy2_ph _exp0).
admit.
admit.
admit.
admit.
qed.

lemma _expm_ll: islossless M(P)._expm.
proof.
proc; wp.
admit.
qed.

lemma _expm_noct_ph _a _b:
 phoare [ M(P)._expm_noct
        : a=_a /\ b=_b ==> res = iterop (BNexp.bn _b) mul_op _a glob_exp0
        ] = 1%r.
admitted.

lemma _expm_ph _a _b:
 phoare [ M(P)._expm
        : a=_a /\ b=_b ==> res = iterop (BNexp.bn _b) mul_op _a glob_exp0
        ] = 1%r.
admitted.

end section.


