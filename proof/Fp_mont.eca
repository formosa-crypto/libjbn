require import AllCore Int IntDiv.


from Jasmin require import JModel_x86.
import SLH64.

require ZModP.
require JBigNumber Bn_base Bn_exp Fp_base.

(* Parameters *)
op nlimbs: int.
axiom gt0_nlimbs: 0 < nlimbs.

clone import JBigNumber.BigN
 with op nlimbs <- nlimbs
      proof gt0_nlimbs by exact gt0_nlimbs.

op glob_P: BN.t.
op glob_mP: BN.t.
op glob_exp0: BN.t.
op glob_Pm2: BN.t.
op glob_P0i: W64.t.
op glob_rMP: BN.t.

op P: int. (* prime modulus *)
axiom P_prime: prime P.

clone import ZModP.ZModField as Zp
 with op p <= P
      rename "zmod" as "zp"
      proof prime_p by exact P_prime.

op inzpM x = inzp (x*bn_modulus).
op oneM = bn_modulus %% P.
op oneMinv = invm bn_modulus P.
op asintM x = asint x * oneMinv %% P.

lemma oneM_oneMinv:
 oneM * oneMinv %% P = 1.
proof.
rewrite /oneM /oneMinv modzMml mulmV//.
 exact P_prime.
print Euclide.
admitted.

op red_op (x: BN2.t): BN.t =
 BN.bn_ofint (BN2.bn x * bn_modulus %% P).

op mul_op (x y: BN.t): BN.t =
 BN.bn_ofint (BN.bn x * BN.bn y * oneMinv %% P).


(* theory hypotheses *)
axiom glob_P_val:
 bn glob_P = P.
axiom glob_mP_val:
 bn glob_mP = bn_modulus - P.
axiom glob_Pm2_val:
 bn glob_Pm2 = P - 2.
axiom glob_OneMP_val:
 bn glob_exp0 = oneM.
axiom glob_P0i_val:
 W64.to_uint glob_P0i * W64.to_uint glob_P.[0] %% W64.modulus = (-1) %% W64.modulus.


clone Bn_base as BNB
 with op nlimbs <- nlimbs,
      theory BigN <- BigN
      proof gt0_nlimbs by exact gt0_nlimbs.

clone Fp_base as FPB
 with op nlimbs <- nlimbs,
      theory BigN <- BigN,
      op glob_P <- glob_P,
      op glob_mP <- glob_mP,
      op glob_exp0 <- glob_exp0,
      op glob_Pm2 <- glob_Pm2,
      op red_op <- red_op,
      theory BNB <- BNB
      proof gt0_nlimbs by exact gt0_nlimbs.

(******************************************************************************
 **                inclusion of the (parametric) extracted module            **
 ** (collected from "extracted_ths/Bn_exp_extr.ec)                           **
 ******************************************************************************)

module BN_M = BNB.M. 
module FP_M = FPB.M.

import BN.A.
import BN2.A.
module M = {
  proc _redM (a:BN2.t, r:BN.t) : BN.t = {
    
    var _P0i:W64.t;
    
    _P0i <- glob_P0i;
    a <- a;
    r <@ BN_M.__mont_redM (a, r, glob_P, glob_mP, _P0i);
    r <- r;
    return (r);
  }
  
  proc __fromM (a:BN.t) : BN.t = {
    
    var _tmp:BN2.t;
    var tmp2:BN.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    tmp2 <- witness;
    tmp2 <- (BN.A.init (fun i => _tmp.[0 + i]));
    tmp2 <@ BN_M.__copy2 (a, tmp2);
    _tmp <- BN2.A.init
            (fun i => if 0 <= i < 0 + 11 then tmp2.[i-0] else _tmp.[i]);
    tmp2 <- (BN.A.init (fun i => _tmp.[11 + i]));
    tmp2 <@ BN_M.__set0 (tmp2);
    _tmp <- BN2.A.init
            (fun i => if 11 <= i < 11 + 11 then tmp2.[i-11] else _tmp.[i]);
    tmp <- _tmp;
    a <@ _redM (tmp, a);
    return (a);
  }

  module Pfp = { proc fun_red = _redM }
  proc __toM (a:BN.t) : BN.t = {
    
    var rMP:BN.t;
    rMP <- witness;
    rMP <- glob_rMP;
    a <- a;
    a <@ FP_M(Pfp)._mulmU (a, rMP);
    a <- a;
    return (a);
  }
}.


(******************************************************************************
 **               Library LEMMAS                                             **
 **                                                                          **
 ******************************************************************************)


lemma redM_prop _a:
 phoare[ M._redM : a = _a ==> res = red_op _a] = 1%r.
admitted.

hoare _mulmU_h _a _b:
 FP_M(M.Pfp)._mulmU:
  a=_a /\ b=_b ==>
 bn res = asint (inzp (bn _a) * inzp (bn _b)).
conseq (FPB._mulmU_h M.Pfp _ _a _b).
admitted.

hoare __toM_h _a:
 M.__toM:
  a = _a ==> bn res = asint (inzpM (bn _a)).
proof.
proc.
wp.
ecall (_mulmU_h a rMP).
admitted.



