require import AllCore IntDiv CoreMap List Distr.
from Jasmin require import JModel_x86.

require import MLeakage.
from JExtract require export Array3.

(* This Theory has no Parameters *)

(* Rewritings:
  "bNUTIL" -> "" (remove qualifier)
*)

module M = {
  proc __mask_zf (mask:W64.t) : bool = {
    
    var zf:bool;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:W64.t;
    
    ( _0,  _1,  _2,  _3, zf,  _4) <- AND_64 mask mask;
    return (zf);
  }
  
  proc __mask_cf (mask:W64.t) : bool = {
    
    var cf:bool;
    var t:W64.t;
    
    t <- (W64.of_int 0);
    (cf, t) <- sbb_64 t mask false;
    return (cf);
  }
  
  proc __cf_mask (cf:bool) : W64.t = {
    
    var mask:W64.t;
    var  _0:bool;
    
    mask <- (W64.of_int 0);
    ( _0, mask) <- sbb_64 mask (W64.of_int 0) cf;
    return (mask);
  }
  
  proc __ncf_mask (cf:bool) : W64.t = {
    
    var mask:W64.t;
    
    mask <@ __cf_mask (cf);
    mask <- NOT_64 mask;
    return (mask);
  }
  
  proc __addacc3 (a:W64.t Array3.t, b1:W64.t, b0:W64.t, k:int) : 
  W64.t Array3.t = {
    var aux: bool;
    var aux_0: W64.t;
    
    var cf:bool;
    
    (aux, aux_0) <- adc_64 a.[(k %% 3)] b0 false;
    cf <- aux;
    a.[(k %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 1) %% 3)] b1 cf;
    cf <- aux;
    a.[((k + 1) %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 2) %% 3)] (W64.of_int 0) cf;
    cf <- aux;
    a.[((k + 2) %% 3)] <- aux_0;
    return (a);
  }
  
  proc __addacc3x2 (a:W64.t Array3.t, x:W64.t, y:W64.t, k:int) : 
  W64.t Array3.t = {
    var aux: bool;
    var aux_0: W64.t;
    
    var b1:W64.t;
    var b0:W64.t;
    var t:W64.t;
    var cf:bool;
    var b2:W64.t;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    
    (b1, b0) <- mulu_64 x y;
    t <- b0;
    b0 <- (b0 `<<` (W8.of_int 1));
    ( _0, cf,  _1,  _2,  _3, b1) <- SHLD_64 b1 t (W8.of_int 1);
    b2 <- MOV_64 (W64.of_int 0);
    (cf, b2) <- adc_64 b2 b2 cf;
    (aux, aux_0) <- adc_64 a.[(k %% 3)] b0 false;
    cf <- aux;
    a.[(k %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 1) %% 3)] b1 cf;
    cf <- aux;
    a.[((k + 1) %% 3)] <- aux_0;
    (aux, aux_0) <- adc_64 a.[((k + 2) %% 3)] b2 cf;
    cf <- aux;
    a.[((k + 2) %% 3)] <- aux_0;
    return (a);
  }
}.

module MLeak = {
  
  proc __mask_zf (mask:W64.t) : bool = {
    var aux_3: bool;
    var aux_2: bool;
    var aux_1: bool;
    var aux_0: bool;
    var aux: bool;
    var aux_4: W64.t;
    
    var zf:bool;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    var  _4:W64.t;
    
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux_3, aux_2, aux_1, aux_0, aux, aux_4) <- AND_64 mask mask;
     _0 <- aux_3;
     _1 <- aux_2;
     _2 <- aux_1;
     _3 <- aux_0;
    zf <- aux;
     _4 <- aux_4;
    return (zf);
  }
  
  proc __mask_cf (mask:W64.t) : bool = {
    var aux_0: bool;
    var aux: W64.t;
    
    var cf:bool;
    var t:W64.t;
    
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- (W64.of_int 0);
    t <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux_0, aux) <- sbb_64 t mask false;
    cf <- aux_0;
    t <- aux;
    return (cf);
  }
  
  proc __cf_mask (cf:bool) : W64.t = {
    var aux_0: bool;
    var aux: W64.t;
    
    var mask:W64.t;
    var  _0:bool;
    
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- (W64.of_int 0);
    mask <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux_0, aux) <- sbb_64 mask (W64.of_int 0) cf;
     _0 <- aux_0;
    mask <- aux;
    return (mask);
  }
  
  proc __ncf_mask (cf:bool) : W64.t = {
    var aux: W64.t;
    
    var mask:W64.t;
    
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <@ __cf_mask (cf);
    mask <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- NOT_64 mask;
    mask <- aux;
    return (mask);
  }
  
  proc __addacc3 (a:W64.t Array3.t, b1:W64.t, b0:W64.t, k:int) : 
  W64.t Array3.t = {
    var aux: bool;
    var aux_0: W64.t;
    
    var cf:bool;
    
    LEAK.leakages <- LeakAddr([(k %% 3)]) :: LEAK.leakages;
    (aux, aux_0) <- adc_64 a.[(k %% 3)] b0 false;
    cf <- aux;
    LEAK.leakages <- LeakAddr([(k %% 3)]) :: LEAK.leakages;
    a.[(k %% 3)] <- aux_0;
    LEAK.leakages <- LeakAddr([((k + 1) %% 3)]) :: LEAK.leakages;
    (aux, aux_0) <- adc_64 a.[((k + 1) %% 3)] b1 cf;
    cf <- aux;
    LEAK.leakages <- LeakAddr([((k + 1) %% 3)]) :: LEAK.leakages;
    a.[((k + 1) %% 3)] <- aux_0;
    LEAK.leakages <- LeakAddr([((k + 2) %% 3)]) :: LEAK.leakages;
    (aux, aux_0) <- adc_64 a.[((k + 2) %% 3)] (W64.of_int 0) cf;
    cf <- aux;
    LEAK.leakages <- LeakAddr([((k + 2) %% 3)]) :: LEAK.leakages;
    a.[((k + 2) %% 3)] <- aux_0;
    return (a);
  }
  
  proc __addacc3x2 (a:W64.t Array3.t, x:W64.t, y:W64.t, k:int) : 
  W64.t Array3.t = {
    var aux_5: bool;
    var aux_4: bool;
    var aux_3: bool;
    var aux_2: bool;
    var aux_1: bool;
    var aux_0: W64.t;
    var aux: W64.t;
    
    var b1:W64.t;
    var b0:W64.t;
    var t:W64.t;
    var cf:bool;
    var b2:W64.t;
    var  _0:bool;
    var  _1:bool;
    var  _2:bool;
    var  _3:bool;
    
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux_0, aux) <- mulu_64 x y;
    b1 <- aux_0;
    b0 <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- b0;
    t <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- (b0 `<<` (W8.of_int 1));
    b0 <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux_5, aux_4, aux_3, aux_2, aux_1, aux_0) <- SHLD_64 b1 t (W8.of_int 1);
     _0 <- aux_5;
    cf <- aux_4;
     _1 <- aux_3;
     _2 <- aux_2;
     _3 <- aux_1;
    b1 <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- MOV_64 (W64.of_int 0);
    b2 <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux_5, aux_0) <- adc_64 b2 b2 cf;
    cf <- aux_5;
    b2 <- aux_0;
    LEAK.leakages <- LeakAddr([(k %% 3)]) :: LEAK.leakages;
    (aux_5, aux_0) <- adc_64 a.[(k %% 3)] b0 false;
    cf <- aux_5;
    LEAK.leakages <- LeakAddr([(k %% 3)]) :: LEAK.leakages;
    a.[(k %% 3)] <- aux_0;
    LEAK.leakages <- LeakAddr([((k + 1) %% 3)]) :: LEAK.leakages;
    (aux_5, aux_0) <- adc_64 a.[((k + 1) %% 3)] b1 cf;
    cf <- aux_5;
    LEAK.leakages <- LeakAddr([((k + 1) %% 3)]) :: LEAK.leakages;
    a.[((k + 1) %% 3)] <- aux_0;
    LEAK.leakages <- LeakAddr([((k + 2) %% 3)]) :: LEAK.leakages;
    (aux_5, aux_0) <- adc_64 a.[((k + 2) %% 3)] b2 cf;
    cf <- aux_5;
    LEAK.leakages <- LeakAddr([((k + 2) %% 3)]) :: LEAK.leakages;
    a.[((k + 2) %% 3)] <- aux_0;
    return (a);
  }
}.


(******************************************************************************
 **               Library LEMMAS                                             **
 **                                                                          **
 ******************************************************************************)


(** LOSSLESS lemmas *)
lemma __mask_zf_ll: islossless M.__mask_zf
by islossless.

lemma __mask_cf_ll: islossless M.__mask_cf
by islossless.

lemma __cf_mask_ll: islossless M.__cf_mask
by islossless.

lemma __ncf_mask_ll: islossless M.__ncf_mask
by islossless.

lemma __addacc3_ll: islossless M.__addacc3
by islossless.

lemma __addacc3x2_ll: islossless M.__addacc3x2
by islossless.

(** CORRECTNESS lemmas [hoare] *)
hoare __mask_zf_h _mask:
 M.__mask_zf : mask=_mask ==> res=(to_uint _mask <> 0).
admitted.

hoare __mask_cf_h _mask:
 M.__mask_cf : mask=_mask ==> res=(to_uint _mask <> 0).
admitted.

hoare __cf_mask_h _cf:
 M.__cf_mask : cf=_cf ==> res=(W64.of_int (-b2i _cf)).
admitted.

hoare __ncf_mask_h _cf:
 M.__ncf_mask : cf=_cf ==> res=(W64.of_int (-b2i (! _cf))).
admitted.

(* obs: to be fixed... *)
hoare __addacc3_h:
 M.__addacc3 : true ==> true.
admitted.

hoare __addacc3x2_h:
 M.__addacc3x2 : true ==> true.
admitted.

(** CORRECTNESS lemmas [phoare] *)
phoare __mask_zf_ph _mask:
 [ M.__mask_zf
 : mask=_mask ==> res=(to_uint _mask <> 0)
 ] = 1%r
by conseq __mask_zf_ll (__mask_zf_h _mask).

phoare __mask_cf_ph _mask:
 [ M.__mask_cf
 : mask=_mask ==> res=(to_uint _mask <> 0)
 ] = 1%r
by conseq __mask_cf_ll (__mask_cf_h _mask).

phoare __cf_mask_ph _cf:
 [ M.__cf_mask 
 : cf=_cf ==> res=(W64.of_int (-b2i _cf))
 ] = 1%r
by conseq __cf_mask_ll (__cf_mask_h _cf).

phoare __ncf_mask_ph _cf:
 [ M.__ncf_mask 
 : cf=_cf ==> res=(W64.of_int (-b2i (! _cf)))
 ] = 1%r
by conseq __ncf_mask_ll (__ncf_mask_h _cf).

(* obs: to be fixed... *)
phoare __addacc3_ph:
 [ M.__addacc3 : true ==> true ] = 1%r
by conseq __addacc3_ll (__addacc3_h ).

phoare __addacc3x2_ph:
 [ M.__addacc3x2 : true ==> true ] = 1%r
by conseq __addacc3x2_ll (__addacc3x2_h ).


(* Constant-time *)
equiv __mask_zf_ct:
 MLeak.__mask_zf ~ MLeak.__mask_zf
 : ={glob LEAK} ==> ={glob LEAK}
by proc; sim.

equiv __mask_cf_ct:
 MLeak.__mask_cf ~ MLeak.__mask_cf
 : ={glob LEAK} ==> ={glob LEAK}
by proc; sim.

equiv __cf_mask_ct:
 MLeak.__cf_mask ~ MLeak.__cf_mask
 : ={glob LEAK} ==> ={glob LEAK}
by proc; sim.

equiv __ncf_mask_ct:
 MLeak.__ncf_mask ~ MLeak.__ncf_mask
 : ={glob LEAK} ==> ={glob LEAK}
by proc; inline*; sim.

equiv __addacc3_ct:
 MLeak.__addacc3 ~ MLeak.__addacc3
 : ={k, glob LEAK} ==> ={glob LEAK}
by proc; sim.

equiv __addacc3x2_ct:
 MLeak.__addacc3x2 ~ MLeak.__addacc3x2
 : ={k, glob LEAK} ==> ={glob LEAK}
by proc; sim.


(* leakage-augmented model... *)
equiv __mask_zf_Lproj:
 M.__mask_zf ~ MLeak.__mask_zf
 : ={arg} ==> ={res}
by sim.

equiv __mask_cf_Lproj:
 M.__mask_cf ~ MLeak.__mask_cf
 : ={arg} ==> ={res}
by sim.

equiv __cf_mask_Lproj:
 M.__cf_mask ~ MLeak.__cf_mask
 : ={arg} ==> ={res}
by sim.

equiv __ncf_mask_Lproj:
 M.__ncf_mask ~ MLeak.__ncf_mask
 : ={arg} ==> ={res}
by sim.

equiv __addacc3_Lproj:
 M.__addacc3 ~ MLeak.__addacc3
 : ={arg} ==> ={res}
by sim.

equiv __addacc3x2_Lproj:
 M.__addacc3x2 ~ MLeak.__addacc3x2
 : ={arg} ==> ={res}
by sim.


