require import AllCore Int IntDiv List.


from Jasmin require import JModel_x86.
import SLH64.

require import MLeakage.
require JBigNumber Bn_util Bn_base Bn_exp Bn_rnd.


(* Parameters *)
op nlimbs: int.
axiom gt0_nlimbs: 0 < nlimbs.

clone import JBigNumber.BigN
 with op nlimbs <- nlimbs
      proof gt0_nlimbs by exact gt0_nlimbs.


op glob_P: BN.t.
op glob_mP: BN.t.
op glob_exp0: BN.t.
op glob_Pm2: BN.t.
op red_op: BN2.t -> BN.t.

axiom prime_P: prime (bn glob_P).
axiom def_mP: bn glob_mP = bn_modulus - bn glob_P.
axiom def_Pm2: bn glob_Pm2 = bn glob_P - 2.


op mul_op (x y: BN.t): BN.t =
 red_op (BN2.bn_ofint (BN.bn x * BN.bn y)).


clone Bn_util as BNUTIL.
module BNUTIL_M = BNUTIL.M.
module BNUTIL_MLeak = BNUTIL.MLeak.

clone Bn_base as BNB
 with op nlimbs <- nlimbs,
      theory BigN <- BigN,
      theory BNUTIL <- BNUTIL
      proof gt0_nlimbs by exact gt0_nlimbs.
module BN_M = BNB.M. 
module BN_MLeak = BNB.MLeak. 

clone Bn_rnd as BNRND
 with op nlimbs <- nlimbs,
      theory BigN <- BigN,
      theory BNUTIL <- BNUTIL,
      theory BNB <- BNB
      proof gt0_nlimbs by exact gt0_nlimbs.
module BNRND_M = BNRND.M. 
module BNRND_MLeak = BNRND.MLeak. 

clone Bn_exp as BNE
 with op nlimbs <- nlimbs,
      op nlimbsexp <- nlimbs,
      op glob_exp0 <- glob_exp0,
      op mul_op <- mul_op,
      theory BigN <- BigN,
      theory BNexp <- BN,
      theory BNUTIL <- BNUTIL,
      theory BNB <- BNB
      proof gt0_nlimbs by exact gt0_nlimbs
      proof gt0_nlimbsexp by exact gt0_nlimbs.
module BNE_M = BNE.M.
module BNE_MLeak = BNE.MLeak.

(******************************************************************************
 **                inclusion of the (parametric) extracted module            **
 ** (collected from "extracted_ths/Fp_base_extr.ec)                          **
 ******************************************************************************)

module type MParam = {
  proc fun_red (r:BN.t, a:BN2.t) : BN.t
}.


module M(P: MParam) = {

  proc _chk_bnds_ (err:W64.t, a:BN.t) : W64.t = {
    
    var p:BN.t;
    var cf:bool;
    var t:W64.t;
    p <- witness;
    p <- glob_P;
    cf <@ BN_M._lt_cf_ (a, p);
    t <@ BNUTIL_M.__ncf_mask (cf);
    err <- (err `|` t);
    return (err);
  }
  
  proc _rnd_ (a:BN.t) : BN.t = {
    
    var p:BN.t;
    p <- witness;
    p <- glob_P;
    a <@ BNRND_M._rsample_ (a, p);
    return (a);
  }
  
  proc _addm_ (r:BN.t, a:BN.t, b:BN.t) : 
  BN.t = {
    
    var cf:bool;
    var lastbit:W64.t;
    var tmp:BN.t;
    var  _0:bool;
    tmp <- witness;
    (cf, r) <@ BN_M._add_ (r, a, b);
    lastbit <- (W64.of_int 0);
    ( _0, lastbit) <- adc_64 lastbit (W64.of_int 0) cf;
    tmp <- glob_mP;
    r <@ BN_M._cminusP_ (r, tmp, lastbit);
    return (r);
  }
  
  proc _addmU_ (a:BN.t, b:BN.t) : BN.t = {
    
    var cf:bool;
    var lastbit:W64.t;
    var tmp:BN.t;
    var  _0:bool;
    tmp <- witness;
    (cf, a) <@ BN_M._addU_ (a, b);
    lastbit <- (W64.of_int 0);
    ( _0, lastbit) <- adc_64 lastbit (W64.of_int 0) cf;
    tmp <- glob_mP;
    a <@ BN_M._cminusP_ (a, tmp, lastbit);
    return (a);
  }
  
  proc _subm_ (r:BN.t, a:BN.t, b:BN.t) : 
  BN.t = {
    
    var cf:bool;
    var tmp:BN.t;
    tmp <- witness;
    (cf, r) <@ BN_M._sub_ (r, a, b);
    tmp <- glob_P;
    r <@ BN_M._caddU_ (r, cf, tmp);
    return (r);
  }
  
  proc _submU_ (a:BN.t, b:BN.t) : BN.t = {
    
    var cf:bool;
    var tmp:BN.t;
    tmp <- witness;
    (cf, a) <@ BN_M._subU_ (a, b);
    tmp <- glob_P;
    a <@ BN_M._caddU_ (a, cf, tmp);
    return (a);
  }
  
  proc _mulm_ (r:BN.t, a:BN.t, b:BN.t) : 
  BN.t = {
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    tmp <- _tmp;
    tmp <@ BN_M._muln_ (tmp, a, b);
    r <@ P.fun_red (r, tmp);
    return (r);
  }
  
  proc _mulmU_ (a:BN.t, b:BN.t) : BN.t = {
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    tmp <- _tmp;
    tmp <@ BN_M._muln_ (tmp, a, b);
    a <@ P.fun_red (a, tmp);
    return (a);
  }
  
  proc _sqrm_ (r:BN.t, a:BN.t) : BN.t = {
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    tmp <- _tmp;
    tmp <@ BN_M._sqrn_ (tmp, a);
    r <@ P.fun_red (r, tmp);
    return (r);
  }
  
  proc _sqrmU_ (a:BN.t) : BN.t = {
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    tmp <- _tmp;
    tmp <@ BN_M._sqrn_ (tmp, a);
    a <@ P.fun_red (a, tmp);
    return (a);
  }
  
  module P_BNEXP = { proc fun_mulU = _mulmU_ 
                     proc fun_sqrU = _sqrmU_ }
  
  proc _invmU_ (a:BN.t) : BN.t = {
    
    var pm2:BN.t;
    pm2 <- witness;
    pm2 <- glob_Pm2;
    a <@ BNE_M(P_BNEXP)._expmU_noct_ (a, pm2);
    return (a);
  }

  proc _invm_ (r a:BN.t) : BN.t = {
    
    var pm2:BN.t;
    pm2 <- witness;
    pm2 <- glob_Pm2;
    r <@ BNE_M(P_BNEXP)._expm_noct_ (r, a, pm2);
    return (r);
  }
}.



module MLeak(P: MParam) = {
  proc _chk_bnds_ (err:W64.t, a:BN.t) : W64.t = {
    var aux_0: bool;
    var aux_1: W64.t;
    var aux: BN.t;
    
    var p:BN.t;
    var cf:bool;
    var t:W64.t;
    p <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- glob_P;
    p <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BN_MLeak._lt_cf_ (a, p);
    cf <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_1 <@ BNUTIL_MLeak.__ncf_mask (cf);
    t <- aux_1;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_1 <- (err `|` t);
    err <- aux_1;
    return (err);
  }
  
  proc _rnd_ (a:BN.t) : BN.t = {
    var aux: BN.t;
    
    var p:BN.t;
    p <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- glob_P;
    p <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <@ BNRND_MLeak._rsample_ (a, p);
    a <- aux;
    return (a);
  }
  
  proc _addm_ (r:BN.t, a:BN.t, b:BN.t) : 
  BN.t = {
    var aux: bool;
    var aux_1: W64.t;
    var aux_0: BN.t;
    
    var cf:bool;
    var lastbit:W64.t;
    var tmp:BN.t;
    var  _0:bool;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux, aux_0) <@ BN_MLeak._add_ (r, a, b);
    cf <- aux;
    r <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_1 <- (W64.of_int 0);
    lastbit <- aux_1;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux, aux_1) <- adc_64 lastbit (W64.of_int 0) cf;
     _0 <- aux;
    lastbit <- aux_1;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- glob_mP;
    tmp <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BN_MLeak._cminusP_ (r, tmp, lastbit);
    r <- aux_0;
    return (r);
  }
  
  proc _addmU_ (a:BN.t, b:BN.t) : BN.t = {
    var aux: bool;
    var aux_1: W64.t;
    var aux_0: BN.t;
    
    var cf:bool;
    var lastbit:W64.t;
    var tmp:BN.t;
    var  _0:bool;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux, aux_0) <@ BN_MLeak._addU_ (a, b);
    cf <- aux;
    a <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_1 <- (W64.of_int 0);
    lastbit <- aux_1;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux, aux_1) <- adc_64 lastbit (W64.of_int 0) cf;
     _0 <- aux;
    lastbit <- aux_1;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- glob_mP;
    tmp <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BN_MLeak._cminusP_ (a, tmp, lastbit);
    a <- aux_0;
    return (a);
  }
  
  proc _subm_ (r:BN.t, a:BN.t, b:BN.t) : 
  BN.t = {
    var aux: bool;
    var aux_0: BN.t;
    
    var cf:bool;
    var tmp:BN.t;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux, aux_0) <@ BN_MLeak._sub_ (r, a, b);
    cf <- aux;
    r <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- glob_P;
    tmp <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BN_MLeak._caddU_ (r, cf, tmp);
    r <- aux_0;
    return (r);
  }
  
  proc _submU_ (a:BN.t, b:BN.t) : BN.t = {
    var aux: bool;
    var aux_0: BN.t;
    
    var cf:bool;
    var tmp:BN.t;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    (aux, aux_0) <@ BN_MLeak._subU_ (a, b);
    cf <- aux;
    a <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <- glob_P;
    tmp <- aux_0;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BN_MLeak._caddU_ (a, cf, tmp);
    a <- aux_0;
    return (a);
  }
  
  proc _mulm_ (r:BN.t, a:BN.t, b:BN.t) : 
  BN.t = {
    var aux_0: BN.t;
    var aux: BN2.t;
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- _tmp;
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <@ BN_MLeak._muln_ (tmp, a, b);
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ P.fun_red (r, tmp);
    r <- aux_0;
    return (r);
  }
  
  proc _mulmU_ (a:BN.t, b:BN.t) : BN.t = {
    var aux_0: BN.t;
    var aux: BN2.t;
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- _tmp;
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <@ BN_MLeak._muln_ (tmp, a, b);
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ P.fun_red (a, tmp);
    a <- aux_0;
    return (a);
  }
  
  proc _sqrm_ (r:BN.t, a:BN.t) : BN.t = {
    var aux_0: BN.t;
    var aux: BN2.t;
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- _tmp;
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <@ BN_MLeak._sqrn_ (tmp, a);
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ P.fun_red (r, tmp);
    r <- aux_0;
    return (r);
  }
  
  proc _sqrmU_ (a:BN.t) : BN.t = {
    var aux_0: BN.t;
    var aux: BN2.t;
    
    var _tmp:BN2.t;
    var tmp:BN2.t;
    _tmp <- witness;
    tmp <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- _tmp;
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <@ BN_MLeak._sqrn_ (tmp, a);
    tmp <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ P.fun_red (a, tmp);
    a <- aux_0;
    return (a);
  }
  
  module P_BNEXP = { proc fun_mulU = _mulmU_
                     proc fun_sqrU = _sqrmU_ }

  proc _invmU_ (a:BN.t) : BN.t = {
    var aux_0: BN.t;
    var aux: BN.t;
    
    var pm2:BN.t;
    pm2 <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- glob_Pm2;
    pm2 <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BNE_MLeak(P_BNEXP)._expmU_noct_ (a, pm2);
    a <- aux_0;
    return (a);
  }

  proc _invm_ (r a:BN.t) : BN.t = {
    var aux_0: BN.t;
    var aux: BN.t;
    
    var pm2:BN.t;
    pm2 <- witness;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux <- glob_Pm2;
    pm2 <- aux;
    LEAK.leakages <- LeakAddr([]) :: LEAK.leakages;
    aux_0 <@ BNE_MLeak(P_BNEXP)._expm_noct_ (r, a, pm2);
    r <- aux_0;
    return (a);
  }
}.


(******************************************************************************
 **               Library LEMMAS                                             **
 **                                                                          **
 ******************************************************************************)




section.

declare module P <: MParam.
declare axiom red_ph _a:
 phoare [ P.fun_red : a=_a ==> res = red_op _a ] = 1%r.

local lemma red_ll: islossless P.fun_red.
proof.
proc*; exlim a => _a.
by call (red_ph _a).
qed.

local lemma red_h _a:
 hoare [ P.fun_red : a=_a ==> res = red_op _a ].
proof.
bypr => &m Ha.
rewrite Pr [mu_not].
have ->: Pr[P.fun_red(r{m}, a{m}) @ &m : true] = 1%r.
 byphoare => //.
 by apply red_ll.
have ->//: Pr[P.fun_red(r{m}, a{m}) @ &m : res = red_op _a] = 1%r.
byphoare (: a=_a ==> _) => //.
by apply red_ph. 
qed.

(** Lossless lemmas *)

lemma _chk_bnds__ll: islossless M(P)._chk_bnds_.
proof.
proc; wp.
call BNUTIL.__ncf_mask_ll.
call BNB._lt_cf__ll.
by auto.
qed.

hoare _chk_bnds__h _err _a:
 M(P)._chk_bnds_
 : err=_err /\ a = _a ==> res = _err `|` W64.of_int (-b2i (! bn _a < bn glob_P)).
proof.
proc.
wp; ecall (BNUTIL.__ncf_mask_h cf).
by ecall (BNB._lt_cf__h a p); auto.
qed.

phoare _chk_bnds__ph _err _a:
 [ M(P)._chk_bnds_
 : err=_err /\ a = _a ==> res = _err `|` W64.of_int (-b2i (! bn _a < bn glob_P))
 ] = 1%r.
proof. by conseq _chk_bnds__ll (_chk_bnds__h _err _a). qed.


lemma _rnd__ll: islossless M(P)._rnd_.
proof.
proc.
call BNRND._rsample__ll.
auto => />.
smt(gt0_prime prime_P).
qed.

lemma _addm__ll: islossless M(P)._addm_.
proc.
call BNB._cminusP__ll.
by wp; call BNB._add__ll; auto.
qed.

lemma _addmU__ll: islossless M(P)._addmU_.
proc.
call BNB._cminusP__ll.
by wp; call BNB._addU__ll; auto.
qed.

lemma _subm__ll: islossless M(P)._subm_.
proc.
call BNB._caddU__ll.
by wp; call BNB._sub__ll; auto.
qed.

lemma _submU__ll: islossless M(P)._submU_.
proc.
call BNB._caddU__ll.
by wp; call BNB._subU__ll; auto.
qed.

lemma _mulm__ll: islossless M(P)._mulm_.
proc.
call red_ll.
by call BNB._muln__ll; auto.
qed.

hoare _mulm__h _a _b:
 M(P)._mulm_: a=_a /\ b=_b ==> res = mul_op _a _b.
proof.
proc; simplify.
wp; ecall (red_h tmp).
wp; ecall (BNB._muln__h a b).
auto => /> r H; rewrite /mul_op.
by rewrite -H BN2.bnK.
qed.

phoare _mulm__ph _a _b:
 [ M(P)._mulm_: a=_a /\ b=_b ==> res = mul_op _a _b ]=1%r.
proof. by conseq _mulm__ll (_mulm__h _a _b). qed.


lemma _mulmU__ll: islossless M(P)._mulmU_.
proc.
call red_ll.
by call BNB._muln__ll; auto.
qed.

hoare _mulmU__h _a _b:
 M(P)._mulmU_: a=_a /\ b=_b ==> res = mul_op _a _b.
proof.
proc; simplify.
wp; ecall (red_h tmp).
wp; ecall (BNB._muln__h a b).
auto => /> r H; rewrite /mul_op.
by rewrite -H BN2.bnK.
qed.

phoare _mulmU__ph _a _b:
 [ M(P)._mulmU_: a=_a /\ b=_b ==> res = mul_op _a _b ]=1%r.
proof. by conseq _mulmU__ll (_mulmU__h _a _b). qed.



lemma _sqrm__ll: islossless M(P)._sqrm_.
proc.
call red_ll.
by call BNB._sqrn__ll; auto.
qed.

hoare _sqrm__h _a:
 M(P)._sqrm_: a=_a ==> res = mul_op _a _a.
proof.
proc; simplify.
wp; ecall (red_h tmp).
wp; ecall (BNB._sqrn__h a).
auto => /> r H; rewrite /mul_op.
by rewrite -H BN2.bnK.
qed.

phoare _sqrm__ph _a:
 [ M(P)._sqrm_: a=_a ==> res = mul_op _a _a ] = 1%r.
proof. by conseq _sqrm__ll (_sqrm__h _a). qed.


lemma _sqrmU__ll: islossless M(P)._sqrmU_.
proc.
call red_ll.
by call BNB._sqrn__ll; auto.
qed.

hoare _sqrmU__h _a:
 M(P)._sqrmU_: a=_a ==> res = mul_op _a _a.
proof.
proc; simplify.
wp; ecall (red_h tmp).
wp; ecall (BNB._sqrn__h a).
auto => /> r H; rewrite /mul_op.
by rewrite -H BN2.bnK.
qed.

phoare _sqrmU__ph _a:
 [ M(P)._sqrmU_: a=_a ==> res = mul_op _a _a ] = 1%r.
proof. by conseq _sqrmU__ll (_sqrmU__h _a). qed.


module MP = M(P).

local equiv sqr_mul_eq:
  MP._sqrmU_ ~ MP._mulmU_
       : ={a} /\ b{2}=a{2} ==> ={res}.
proof.
proc*.
ecall{1} (_sqrmU__ph a{1}).
by ecall{2} (_mulmU__ph a{2} b{2}).
qed.

lemma _invm__ll: islossless M(P)._invm_.
proc.
have H := (BNE._expm_noct__ll MP.P_BNEXP sqr_mul_eq _mulmU__ph).
by call H; auto.
qed.

lemma _invmU__ll: islossless M(P)._invmU_.
proc.
have H := (BNE._expmU_noct__ll MP.P_BNEXP sqr_mul_eq _mulmU__ph).
by call H; auto.
qed.

hoare _invm__h _a:
 M(P)._invm_ :
 a=_a ==> res = iterop (bn glob_Pm2) mul_op _a glob_exp0.
proof.
proc.
have H := (BNE._expm_noct__h MP.P_BNEXP sqr_mul_eq _mulmU__ph).
by ecall (H a pm2); auto.
qed.

hoare _invmU__h _a:
 M(P)._invmU_ :
 a=_a ==> res = iterop (bn glob_Pm2) mul_op _a glob_exp0.
proof.
proc.
have H := (BNE._expmU_noct__h MP.P_BNEXP sqr_mul_eq _mulmU__ph).
by ecall (H a pm2); auto.
qed.

phoare _invm__ph _a:
 [ M(P)._invm_
 : a=_a ==> res = iterop (bn glob_Pm2) mul_op _a glob_exp0
 ] =1%r.
proof. by conseq _invm__ll (_invm__h _a). qed.

phoare _invmU__ph _a:
 [ M(P)._invmU_
 : a=_a ==> res = iterop (bn glob_Pm2) mul_op _a glob_exp0
 ] =1%r.
proof. by conseq _invmU__ll (_invmU__h _a). qed.

end section.

