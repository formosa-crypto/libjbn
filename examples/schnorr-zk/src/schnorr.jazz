
require "bn_modp2048.jinc"

param int nlimbs = modp2048_nlimbs;


inline fn __commitment(
) -> stack u64[nlimbs], stack u64[nlimbs] {
 stack u64[nlimbs] _secret_power _commitment;
 reg ptr u64[nlimbs] secret_power commitment;
 secret_power = _secret_power;
 commitment = _commitment;
 secret_power = FQM_rnd_(secret_power);
 commitment = FPM_gexp_(commitment, secret_power);
 _secret_power = secret_power;
 _commitment = commitment; //OBS: in Montgomery form
 return _commitment, _secret_power;
}

inline fn __challenge(
) -> stack u64[nlimbs] {
 stack u64[nlimbs] _challenge;
 reg ptr u64[nlimbs] challenge order;
 challenge = _challenge;
 order = modp2048_glob_Q;
 challenge = BN_rsample_(challenge, order);
 _challenge = challenge;
 return _challenge;
}

inline fn __response
( stack u64[nlimbs] _witness _secret_power _challenge
) -> stack u64[nlimbs] {
 stack u64[nlimbs] _t;
 reg ptr u64[nlimbs] t witness secret_power challenge;
 stack u64 _err;

 // Check miss-representation errors
 _err = 0;
 witness = _witness;
 _err = FQM_chk_bnds_(_err, witness);
 secret_power = _secret_power;
 _err = FQM_chk_bnds_(_err, secret_power);
 challenge = _challenge;
 _err = FQM_chk_bnds_(_err, challenge);

 // actual prover code
 t = _t;
 t = BN_mov_(t, witness);
 t = FQM_toM_(t);
 challenge = _challenge;
 t = FQM_mulmU_(t, challenge);
 secret_power = _secret_power;
 t = FQM_addmU_(t, secret_power);

 // set ERR on error
 t = BN_set_err_(t, _err);
 _t = t;
 return _t;
}

inline fn __verify
( stack u64[nlimbs] _statement _commitment _challenge _response
) -> reg u64 {
 stack u64[nlimbs] _t1 _t2;
 reg ptr u64[nlimbs] t1 t2 statement commitment challenge response;
 reg u64 r err;
 stack u64  _err;

 // Check miss-representation errors (0: no-err; -1: err)
 _err = 0;
 statement = _statement;
 _err = FPM_chk_bnds_(_err, statement);
 commitment = _commitment;
 _err = FPM_chk_bnds_(_err, commitment);
 challenge = _challenge;
 _err = FQM_chk_bnds_(_err, challenge);
 response = _response;
 _err = FQM_chk_bnds_(_err, response);

 // actual verifier code
 t2 = _t2;
 statement = _statement;

 t2 = BN_mov_(t2, statement);
 t2 = FPM_toM_(t2); // statM

 challenge = _challenge;
 t2 = t2;
 t1 = _t1;
 t1 = FPM_expm_(t1, t2, challenge); // statM ^ chall

 t1 = t1;
 commitment = _commitment;
 t1 = FPM_mulmU_(t1, commitment); // commM *M statM ^ chall
 _t1 = t1;
 t2 = _t2;
 response = _response;
 t2 = FPM_gexp_(t2, response); // gM ^ resp
 _t2 = t2;
 t1 = _t1;
 r = BN_eq_(t1, t2); // gM ^ resp  ==  commM *M statM ^ chall

 // fail on ERR
 err = _err;
 err = #NOT(err);
 r &= err;

 return r;
}
 
 
export fn commitment
( reg u64 commitment_p random_power_p
) { 
  stack u64[nlimbs] _commitment _random_power;
  reg ptr u64[nlimbs] commitment random_power;

  commitment_p   = commitment_p;   // relax ABI contraints
  random_power_p = random_power_p; // relax ABI contraints

  _commitment, _random_power = __commitment();

  commitment = _commitment;
  BN_store_(commitment_p, commitment);
  random_power = _random_power;
  BN_store_(random_power_p, random_power);
}


export fn response
( reg u64 witness_p random_power_p challenge_p response_p
) { 
  stack u64[nlimbs] _witness _random_power _challenge _response;
  reg ptr u64[nlimbs] witness random_power challenge response;

  witness       = _witness;
  witness       = BN_load_(witness, witness_p);
  random_power  = _random_power;
  random_power  = BN_load_(random_power, random_power_p);
  challenge     = _challenge;
  challenge     = BN_load_(challenge, challenge_p);
  response      = _response;
  _response     = __response(witness,random_power,challenge);
  response      = _response;
  BN_store_(response_p, response);
}


export fn verify
( reg u64 statement_p commitment_p challenge_p response_p result_p
) { 
  stack u64[nlimbs] _statement _commitment _challenge _response;
  reg ptr u64[nlimbs] statement commitment challenge response;
  reg u64 result;
  stack u64 _result_p;
  
  _result_p = result_p;

  statement  = _statement;
  statement  = BN_load_(statement, statement_p);
  _statement = statement;
  commitment = _commitment;
  commitment = BN_load_(commitment, commitment_p);
  _commitment = commitment;
  challenge  = _challenge;
  challenge  = BN_load_(challenge, challenge_p);
  _challenge  = challenge;
  response   = _response;
  response   = BN_load_(response, response_p);
  _response  = response;

  result = __verify(statement,commitment,challenge,response);

  result_p = _result_p;
  [result_p] = result; 
}

export fn challenge(reg u64 challenge_p) 
{ 
  stack u64[nlimbs] _challenge;
  reg ptr u64[nlimbs] challenge;

  challenge_p = challenge_p;
  _challenge = __challenge();

  challenge = _challenge;
  BN_store_(challenge_p, challenge);
}

