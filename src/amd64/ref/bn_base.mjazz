/* This file is indeed a template for a pyhton prototype
   intended to emulate and exercise the "Parametric Modules"
   feature propose in https://github.com/jasmin-lang/jasmin/issues/519.
*/

/*
modsignature { int nlimbs; }
*/

/*
   GENERIC CODE (parametric on the number of limbs)

   Name Conventions:
     _* <- local (non-exported) jasmin functions
     __* <- inlined functions


*/



inline fn BNUTIL__mask_zf(reg u64 mask) -> reg bool {
  reg bool zf;
  (_, _, _, _, zf, _) = #AND(mask, mask);
  return zf;
}

//@ ensures: \res = (mask != 0)
inline fn BNUTIL__mask_cf(reg u64 mask) -> reg bool {
  reg bool cf;
  reg u64 t;
  t = 0;
  cf, t -= mask;
  return cf;
}

inline fn BNUTIL__cf_mask(reg bool cf) -> reg u64 {
  reg u64 mask;
  mask = 0;
  cf, mask += 0 + cf;
  mask = -mask;
  return mask;
}

// ACCUMULATOR for product-scanning 
// regs: params(5)
inline fn BNUTIL__addacc3
( reg u64 b1 b0
, reg u64[3] a
, inline int k
) -> reg u64[3] {
  reg bool cf;
  cf, a[k % 3] += b0;
  cf, a[(k+1) % 3] += b1 + cf;
  cf, a[(k+2) % 3] += 0 + cf;
  return a;
}

// ACCUMULATOR for product-scanning (sqr)
// regs: params(5) + 3 = 8
inline fn BNUTIL__addacc3x2
( reg u64 x y
, reg u64[3] a
, inline int k
) -> reg u64[3] {
  reg bool cf;
  reg u64 t b2 b1 b0;

  b1, b0 = x * y;

  t = b0; 
  b0 <<= 1;
  _, cf, _, _, _, b1 = #SHLD(b1, t, 1);

  b2 = #MOV(0);
  cf, b2 += b2 + cf;
  cf, a[k % 3] += b0;
  cf, a[(k+1) % 3] += b1 + cf;
  cf, a[(k+2) % 3] += b2 + cf;
  return a;
}


/* Loads BN from memory
 */
inline fn ${qual}__load
( reg u64 ap
, reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}]
{
  inline int i;
  reg u64 t;

  for i = 0 to ${nlimbs} {
    t = [ap + 8*i];
    a[i] = t;
  }

  return a;
}

/* Stores a BN into memory */
inline fn ${qual}__store
( reg u64 ap,
  reg const ptr u64[${nlimbs}] a
)
{
  inline int i;
  reg u64 t;

  for i = 0 to ${nlimbs} {
    t = a[i];
    [ap + 8*i] = t;
  }
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn ${qual}__eq_zf
( reg const ptr u64[${nlimbs}] a b
) -> reg bool {
  inline int i;
  reg u64 acc t;
  reg bool zf;

  acc = 0;
  for i = 0 to ${nlimbs} {
    t = a[i];
    t ^= b[i];
    acc |= t;
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
    
  return zf;
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn ${qual}__eq
( reg const ptr u64[${nlimbs}] a b
) -> reg u64 /* 0 or 1 */ {
  inline int i;
  reg u64 are_equal res;
  reg bool zf;

  zf = ${qual}__eq_zf(a, b);
  res = 0;
  are_equal = 1;
  res = are_equal if zf;
    
  return res;
}

//@ ensures \result = bn(a) == bn(b)
fn ${qual}_eq
( reg const ptr u64[${nlimbs}] a b
) -> reg u64 /* 0 or 1 */ {
  reg u64 r;
  r = ${qual}__eq(a,b);
  return r;
}

//@ ensures \result == (bn(a) == bn(b));
inline fn ${qual}_eq_
( reg const ptr u64[${nlimbs}] a b
) -> reg u64 /* 0 or 1 */ {
  reg u64 r;
  a = a;
  b = b;
  r = ${qual}_eq(a,b);
  r = r;
  return r;
}

//@ ensures res == if bn(a)=0 then 1 else 0;
inline fn ${qual}__test0_zf
( reg const ptr u64[${nlimbs}] a) -> reg bool {
  inline int i;
  reg u64 acc;
  reg bool zf;

  acc = a[0];
  for i = 1 to ${nlimbs} {
    acc |= a[i];
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
  return zf;
}

//@ ensures res == if bn(a)=0 then 1 else 0;
inline fn ${qual}__test0
( reg const ptr u64[${nlimbs}] a) -> reg u64 {
  reg u64 is_zero res;
  reg bool zf;

  res = 0;
  is_zero = 1;    
  zf = ${qual}__test0_zf(a);
  res = is_zero if zf;

  return res;
}

//@ ensures \result == (bn(a)==0);
fn ${qual}_test0
( reg const ptr u64[${nlimbs}] a
) -> reg u64 /* 0 or 1 */ {
  reg u64 r;
  r = ${qual}__test0(a);
  return r;
}

//@ ensures \result == a;
inline fn ${qual}__copy
( reg const ptr u64[${nlimbs}] a
) -> stack u64[${nlimbs}] {
  inline int i;
  reg u64 t;
  stack u64[${nlimbs}] r;
    
  for i = 0 to ${nlimbs} {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

//@ ensures \result == a;
inline fn ${qual}__copy2
( reg const ptr u64[${nlimbs}] a
, reg mut ptr u64[${nlimbs}] r
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;
    
  for i = 0 to ${nlimbs} {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

//@ ensures \result = if cond then b else a;
inline fn ${qual}__cmov
( reg bool cond
, reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;
    
  for i = 0 to ${nlimbs} {
    t = a[i];
    t = b[i] if cond;
    a[i] = t;
  }
    
  return a;
}

inline fn ${qual}__cswap_mask
 ( reg u64 mask // 0/-1
 , reg mut ptr u64[${nlimbs}] x
 , reg mut ptr u64[${nlimbs}] y
 ) -> reg ptr u64[${nlimbs}] , reg ptr u64[${nlimbs}] {
  reg u64 tmp1, tmp2;
  inline int i;
  for i = 0 to ${nlimbs} {
   tmp1   = x[i];
   tmp1  ^= y[i];
   tmp1  &= mask;
   x[i]  ^= tmp1;
   y[i]  ^= tmp1;
  }

  return x, y;
}

inline fn ${qual}__cswap_cf
 ( reg bool cf
 , reg mut ptr u64[${nlimbs}] x
 , reg mut ptr u64[${nlimbs}] y
 ) -> reg ptr u64[${nlimbs}] , reg ptr u64[${nlimbs}] {
  reg u64 mask, tmp1, tmp2;
  inline int i;
  mask = BNUTIL__cf_mask(cf);
  for i = 0 to ${nlimbs} {
   tmp1   = x[i];
   tmp1  ^= y[i];
   tmp1  &= mask;
   x[i]  ^= tmp1;
   y[i]  ^= tmp1;
  }

  return x, y;
}


//@ ensures \forall v in \result; v == 0;
inline fn ${qual}__fill
( reg u64 x
, reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  for i = 0 to ${nlimbs} {
    a[i] = x;
  }
  return a;
}

//@ ensures \forall v in \result; v == 0;
inline fn ${qual}__set0
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;
  t = 0;
  a = ${qual}__fill(t, a);
  return a;
}

inline fn ${qual}__cfill
( reg bool b
, reg u64 x
, reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  for i = 0 to ${nlimbs} {
    a[i] = x;
  }
  return a;
}

inline fn ${qual}__set_err
( stack u64 _err
, reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 err;
  err = _err;
  for i = 0 to ${nlimbs} {
    a[i] |= err;
  }
  return a;
}


//@ ensures bn(\result) = a + cf*2^(64*k)
inline fn ${qual}__carrypropU
( reg mut ptr u64[${nlimbs}] a,
  reg bool cf,
  inline int k
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  for i=k to ${nlimbs}
  { cf, a[i] += 0 + cf; }

  return cf, a;
}

/* multi-limb addition (update inplace) */
inline fn ${qual}__addU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] += t;
  for i=1 to ${nlimbs} { 
   t = b[i];
   cf, a[i] += t + cf;
  }

  return cf, a;
}

inline fn ${qual}__add
( reg const ptr u64[${nlimbs}] a b
, reg mut ptr u64[${nlimbs}] r
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = a[0];
  cf, t += b[0];
  r[0] = t;
  for i=1 to ${nlimbs} { 
   t = a[i];
   cf, t += b[i] + cf;
   r[i] = t;
  }

  return cf, r;
}

/* Non-inlined versions */
fn ${qual}_addU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  cf, a = ${qual}__addU(a, b);
  return cf, a;
}

fn ${qual}_add
( reg const ptr u64[${nlimbs}] a b
, reg mut ptr u64[${nlimbs}] r
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  cf, r = ${qual}__add(a, b, r);
  return cf, r;
}

/* performs multi-limb subtraction (inplace) */
inline fn ${qual}__subU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] -= t;
  for i=1 to ${nlimbs} {
   t = b[i];
   cf, a[i] -= t - cf;
  }

  return cf, a;
}

inline fn ${qual}__sub
( reg const ptr u64[${nlimbs}] a b
, reg mut ptr u64[${nlimbs}] r
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = a[0];
  cf, t -= b[0];
  r[0] = t;
  for i=1 to ${nlimbs} {
   t = a[i];
   cf, t -= a[i] - cf;
   r[i] = t;
  }

  return cf, r;
}

/* comparison * */
inline fn ${qual}__lt_cf
(reg const ptr u64[${nlimbs}] a b
) -> reg bool {
  inline int i;
  reg bool cf;
  reg u64 t;

  t = a[0];
  cf, t -= b[0];
  for i=1 to ${nlimbs} {
   t = a[i];
   cf, t -= b[i] - cf;
  }

  return cf;
}

inline fn ${qual}__negU
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg bool cf;
  reg u64 t;

  t = 0;
  cf, t -= a[0];
  a[0] = t;
  for i=1 to ${nlimbs} {
   t = 0;
   cf, t -= a[i] - cf;
   a[i] = t;
  }

  return a;
}

inline fn ${qual}__neg
( reg const ptr u64[${nlimbs}] a
, reg mut ptr u64[${nlimbs}] r
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg bool cf;
  reg u64 t;

  t = 0;
  cf, t -= a[0];
  r[0] = t;
  for i=1 to ${nlimbs} {
   t = 0;
   cf, t -= a[i] - cf;
   r[i] = t;
  }

  return r;
}

/* Non-inlined versions */
fn ${qual}_subU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  cf, a = ${qual}__subU(a, b);
  return cf, a;
}

fn ${qual}_sub
( reg const ptr u64[${nlimbs}] a b
, reg mut ptr u64[${nlimbs}] r
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  cf, r = ${qual}__sub(a, b, r);
  return cf, r;
}

/* random number */
inline fn ${qual}__rnd
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  a = a;
  a = #randombytes(a);
  a = a;
  return a;
}

/* rejection sampling */
inline fn ${qual}__rsample
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] bnd
) -> reg ptr u64[${nlimbs}] {
  reg bool cf;
  while {
    a = ${qual}__rnd(a);
    cf = ${qual}__lt_cf(a, bnd);
  }(!cf)
  return a;
}

/* ensures: res = (sign(a-b), |a-b|)*/
inline fn ${qual}__subU_signabs
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  stack u64[${nlimbs}] tmp;
  reg bool cf;
  _, tmp = ${qual}__sub(b, a, tmp);
  cf, a = ${qual}__subU(a, b);
  a = ${qual}__cmov(cf, a, tmp);
  return (cf, a);
}

/*
// b = if mask then -a else 0
inline fn ${qual}__maskedneg
( reg u64 mask
, reg const ptr u64[${nlimbs}] a
, reg mut ptr u64[${nlimbs}] b
) -> reg bool, reg u64[${nlimbs}] {
  inline int i;
  reg bool cf;
  reg u64 t1 t2;

  t1 = a[0];
  t2 = 0;
  t1 &= mask;
  cf, t2 -= t1;
  b[0] = t2;
  for i=1 to ${nlimbs} {
   t1 = a[i];
   t2 = 0;
   t1 &= mask;
   cf, t2 -= t1 - cf;
   b[i] = t2;
  }

  return cf, b; // obs: mask => cf \/ bn a = 0
}
*/

inline fn ${qual}__cnegU
( reg u64 cond
, reg mut ptr u64[${nlimbs}] a
) -> reg u64[${nlimbs}] {
  reg bool cf;
  stack u64[${nlimbs}] x;
  x = ${qual}__neg(a, x);
  cf = BNUTIL__mask_cf(cond);
  a = ${qual}__cmov(cf, a, x);
  return a;
}


/* CONDITIONAL-ADD */
//@ ensures bn(res) == if cf then bn(x)+bn(y) else bn(x);
inline fn ${qual}__caddU
( reg bool cf
, reg mut ptr u64[${nlimbs}] x
, reg ptr u64[${nlimbs}] y
) -> reg ptr u64[${nlimbs}]
{
  inline int i;
  reg u64 t t0;
  stack u64[${nlimbs}] _tmp;
  reg ptr u64[${nlimbs}] tmp;

  _tmp = ${qual}__copy(y);

  t0 = 0;
  for i = 0 to ${nlimbs} {
    t = _tmp[i];
    t = t0 if !cf;
    _tmp[i] = t;
  }

  tmp = _tmp;
  _, x = ${qual}__addU( x, tmp );

  return x;
}


/** 
  * MULTIPLICATION: product-scanning
  */

// regs: params(5) + 3 = 8
inline fn ${qual}__muln_innerloop
( inline int k istart iend
, reg ptr u64[${nlimbs}] a b
, reg u64[3] x
) -> reg u64[3] {
  reg u64 t1, t0;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    t0 = a[i];
    t1, t0 = t0 * b[j];
    x = BNUTIL__addacc3(t1, t0, x, k);
  }
  return x;
}

// regs: params(3) + call(3) + 3(+2) = 9
inline fn ${qual}__muln
( reg const ptr u64[${nlimbs}] a b
, reg mut ptr u64[2*${nlimbs}] r
) -> reg ptr u64[2*${nlimbs}] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;


  t0 = a[0];
  t1, t0 = t0 * b[0];
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
  for k = 1 to ${nlimbs} {
    x = ${qual}__muln_innerloop(k, 0, k+1, a, b, x);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = ${nlimbs} to 2*${nlimbs}-1 {
    x = ${qual}__muln_innerloop(k, k-${nlimbs}+1, ${nlimbs}, a, b, x);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*${nlimbs}-1] = x[(2*${nlimbs}-1) % 3];
  return r;
}

// regs: params(3) + call(6) = 9
fn ${qual}_muln
( reg ptr u64[${nlimbs}] a b
, reg ptr u64[2*${nlimbs}] r
) -> reg ptr u64[2*${nlimbs}] {
  r = ${qual}__muln(a, b, r);
  return r;
}


/* obs: yet another instance of the innerloop, when
 both parameters are equal */
/*
BENCH: j_fp_exp_low2                    = 105892,107110,108524
BENCH: j_fp_exp_low                     = 112564,113720,114904
BENCH:   fp_exp                         = 110964,111532,112152
*/
/*
inline fn _addacc3x2_
( reg u64 x y
, reg u64[3] a
, inline int k
) -> reg u64[3] {
  reg bool cf;
  reg u64 b2, b1, b0;
  b1, b0 = x * y;
  _, _, _, _, _, b2 = #set0();

  _, cf, _, _, _, b0 = #SHL(b0, 1);
  _, cf, b1 = #RCL(b1, 1, cf);

  cf, b2 += b2 + cf;
  cf, a[k % 3] += b0;
  cf, a[(k+1) % 3] += b1 + cf;
  cf, a[(k+2) % 3] += b2 + cf;
  return a;
}
*/
/*
BENCH: j_fp_exp_low2                    = 103628,104758,105930
BENCH: j_fp_exp_low                     = 112202,113378,114598
BENCH:   fp_exp                         = 110860,111444,112062
*/

// regs: params(4) + 2 = 6 
inline fn ${qual}__sqrn_innerloop
( inline int k istart iend
, reg const ptr u64[${nlimbs}] a
, reg u64[3] x
) -> reg u64[3] {
  reg u64 ti, tj;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    ti = a[i];
    tj = a[j];
    x = BNUTIL__addacc3x2(ti, tj, x, k);
  }
  return x;
}

inline fn ${qual}__sqrn
( reg const ptr u64[${nlimbs}] a
, reg mut ptr u64[2*${nlimbs}] r
) -> reg ptr u64[2*${nlimbs}] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;

  t0 = a[0];
  t1, t0 = t0 * t0;
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;

  for k = 1 to ${nlimbs} {
    x = ${qual}__sqrn_innerloop(k, 0, (k+1)/2, a, x);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = BNUTIL__addacc3(t1, t0, x, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = ${nlimbs} to 2*${nlimbs}-1 {
    x = ${qual}__sqrn_innerloop(k, k-${nlimbs}+1, (k+1)/2, a, x);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = BNUTIL__addacc3(t1, t0, x, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*${nlimbs}-1] = x[(2*${nlimbs}-1) % 3];
  return r;
}

fn ${qual}_sqrn
( reg const ptr u64[${nlimbs}] a
, reg mut ptr u64[2*${nlimbs}] r
) -> reg ptr u64[2*${nlimbs}] {
  r = ${qual}__sqrn(a, r);
  return r;
}


/* x-P if P<=x else x
   (remark: [x;lastbit] < 2*P)
 */
inline fn ${qual}__cminusP
 ( reg u64 lastbit         // 0/1
 , reg mut ptr u64[${nlimbs}] x   //
 , reg const ptr u64[${nlimbs}] mP  // R-P
 ) -> reg ptr u64[${nlimbs}]  // [x,lastbit]<P ? x : [x,lastbit]-P
{
  inline int i;
  reg bool _cf;
  stack u64[${nlimbs}] _tmp;
  reg ptr u64[${nlimbs}] tmp;

  _tmp = ${qual}__copy(x);
   tmp = _tmp;
  _cf, tmp = ${qual}__addU(tmp, mP);

  _, lastbit += 0 + _cf;
  _, _cf, _, _, _, _ = #NEG(lastbit);

  x = ${qual}__cmov(_cf, x, tmp);
  return x;
}

// ////////////////////////////////////
// regs: params(3) + call(3) + 3 = 9
inline fn ${qual}__mont_redM
( reg const ptr u64[2*${nlimbs}] a
, reg mut ptr u64[${nlimbs}] r
, stack u64[${nlimbs}] _P
, stack u64[${nlimbs}] _mP
, stack u64 _U0
) -> reg ptr u64[${nlimbs}] {
  inline int k;
  reg bool cf;
  reg ptr u64[${nlimbs}] P mP;
  reg u64 t t0 t1 zero p0 lastbit;
  reg u64[3] x;

//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
//  _, _, _, _, _, x[1] = #set0();
  x[1] = 0;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;

  for k = 0 to ${nlimbs} {
    P = _P;
    x = ${qual}__muln_innerloop(k, 0, k, r, P, x); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = BNUTIL__addacc3(zero, t0, x, k);
    t0 = x[k % 3];
    _, t0 = t0 * _U0;
    r[k] = t0;
    t1, t0 = t0 * _P[0];
    x = BNUTIL__addacc3(t1, t0, x, k);
  }
  for k = ${nlimbs} to 2*${nlimbs}-1 {
    P = _P;
    x = ${qual}__muln_innerloop(k, k-${nlimbs}+1, ${nlimbs}, r, P, x); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = BNUTIL__addacc3(zero, t0, x, k);
    t0 = x[k % 3];
    r[k-${nlimbs}] = t0;
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
  }

  lastbit = 0;
  cf, x[(2*${nlimbs}-1) % 3] += a[2*${nlimbs}-1];
  _, lastbit += 0 + cf;

  r[${nlimbs}-1] = x[(2*${nlimbs}-1) % 3];

  mP = _mP;
  r = ${qual}__cminusP(lastbit, r, mP);
  return r;
}




/* pack two bignums into a double bignum */
inline fn ${qual}__pack2
( reg const ptr u64[${nlimbs}] lo hi
, reg mut ptr u64[2*${nlimbs}] r
) -> reg ptr u64[2*${nlimbs}]
{
  inline int i;
  reg u64 t;

  for i = 0 to ${nlimbs} {
    t = lo[i];
    r[i] = t;
  }
  for i = 0 to ${nlimbs} {
    t = hi[i];
    r[${nlimbs}+i] = t;
  }

  return r;
}

inline fn BNBASE_toec(reg u64 ap) {
  stack u64[${nlimbs}] a b;
  stack u64[2*${nlimbs}] c;
  reg u64 x y;
  stack u64 _x;
  reg bool cf of;
  a = ${qual}__load(ap, a);
  b = ${qual}__load(ap, a);
  ${qual}__store(ap, a);
  //x = __bn_eq(a,b);
  x = ${qual}_eq_(a,b);
  _x = x;
  //x = __bn_test0(a);
  x = ${qual}_test0(a);
  b = ${qual}__copy(a);
  b = ${qual}__copy2(a, b);
  a = ${qual}__cmov(cf, a, b);
  a = ${qual}__set_err(_x, a);
  a = ${qual}__set0(a);
  //cf, a = ${qual}__addU(a, b);
  cf, a = ${qual}_addU(a, b);
  //cf, a = ${qual}__subU(a, b);
  cf, a = ${qual}_subU(a, b);
  cf = ${qual}__lt_cf(a,b);
  a = ${qual}__caddU(cf, a, b);
  a = ${qual}__rsample(a,b);
  c = ${qual}_muln(a,b,c);
  a = ${qual}__mont_redM(c,a,b,b,_x);
}
