/* This file is indeed a template for a pyhton prototype
   intended to emulate and exercise the "Parametric Modules"
   feature propose in https://github.com/jasmin-lang/jasmin/issues/519.

BN_BASE_FNS = _load_ _store_ _eq_zf_ _eq_ _test0_zf_ _test0_ __copy _mov_ _cmov_ _cswap_mask_ _cswap_cf_ _fill_ _set0_ __cfill _or_mask_ _and_mask_ _set_err_ __carrypropU _addcU_ _addU_ _addc_ _add_ _subcU_ _subU_ _subc_ _sub_ _lt_cf_ _ltc_cf_ _negU_ _negcU_ _neg_ _negc_ _cnegU_ _caddU_ _muln_ _sqrn_ _cminusP_ __mont_redM _pack2_

*/

modsignature { param int nlimbs; }

/*
   GENERIC CODE (parametric on the number of limbs)

   Name Conventions:
     _* <- local (non-exported) jasmin functions
     __* <- inlined functions


*/

from Libjbn require "bn_util.jinc"

/* Loads BN from memory
 */
inline fn __load
( reg mut ptr u64[nlimbs] a
, reg u64 ap
) -> reg ptr u64[nlimbs]
{
  inline int i;
  reg u64 t;

  for i = 0 to nlimbs {
    t = [ap + 8*i];
    a[i] = t;
  }

  return a;
}

//#[returnaddress=reg]
fn _load
( reg mut ptr u64[nlimbs] a
, reg u64 ap
) -> reg ptr u64[nlimbs]
{
  a = __load(a, ap);
  return a;
}

inline fn _load_
( reg mut ptr u64[nlimbs] a
, reg u64 ap
) -> reg ptr u64[nlimbs]
{
  a = a; ap = ap;
  a = _load(a, ap);
  a = a;
  return a;
}

/* Stores a BN into memory */
inline fn __store
( reg u64 ap,
  reg const ptr u64[nlimbs] a
)
{
  inline int i;
  reg u64 t;

  for i = 0 to nlimbs {
    t = a[i];
    [ap + 8*i] = t;
  }
}

fn _store
( reg u64 ap,
  reg const ptr u64[nlimbs] a
) {
  __store(ap, a);
}

inline fn _store_
( reg u64 ap,
  reg const ptr u64[nlimbs] a
) {
  ap = ap; a = a;
  __store(ap, a);
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn __eq_zf
( reg const ptr u64[nlimbs] a b
) -> reg bool {
  inline int i;
  reg u64 acc t;
  reg bool zf;

  acc = 0;
  for i = 0 to nlimbs {
    t = a[i];
    t ^= b[i];
    acc |= t;
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
    
  return zf;
}

fn _eq_zf
( reg const ptr u64[nlimbs] a b
) -> reg bool {
  reg bool zf;
  zf = __eq_zf(a, b);
  return zf;
}

inline fn _eq_zf_
( reg const ptr u64[nlimbs] a b
) -> reg bool {
  reg bool zf;
  a = a; b = b;
  zf = _eq_zf(a, b);
  return zf;
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn _eq_
( reg const ptr u64[nlimbs] a b
) -> reg u64 /* 0 or 1 */ {
  inline int i;
  reg u64 are_equal res;
  reg bool zf;

  zf = _eq_zf_(a, b);
  res = 0;
  are_equal = 1;
  res = are_equal if zf;
    
  return res;
}

//@ ensures res == if bn(a)=0 then 1 else 0;
inline fn __test0_zf
( reg const ptr u64[nlimbs] a
) -> reg bool {
  inline int i;
  reg u64 acc;
  reg bool zf;

  acc = a[0];
  for i = 1 to nlimbs {
    acc |= a[i];
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
  return zf;
}

//@ ensures \result == (bn(a)==0);
fn _test0_zf
( reg const ptr u64[nlimbs] a
) -> reg bool {
  reg bool zf;
  zf = __test0_zf(a);
  return zf;
}

inline fn _test0_zf_
( reg const ptr u64[nlimbs] a
) -> reg bool {
  reg bool zf;
  a = a;
  zf = __test0_zf(a);
  return zf;
}

//@ ensures res == if bn(a)=0 then 1 else 0;
inline fn _test0_
( reg const ptr u64[nlimbs] a
) -> reg u64 {
  reg u64 is_zero res;
  reg bool zf;

  res = 0;
  is_zero = 1;    
  zf = _test0_zf_(a);
  res = is_zero if zf;

  return res;
}

//@ ensures \result == a;
inline fn __copy
( reg const ptr u64[nlimbs] a
) -> stack u64[nlimbs] {
  inline int i;
  reg u64 t;
  stack u64[nlimbs] r;
    
  for i = 0 to nlimbs {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

//@ ensures \result == a;
inline fn __mov
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
    
  for i = 0 to nlimbs {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

fn _mov
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[nlimbs] {
  r = __mov(r, a);
  return r;
}

inline fn _mov_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[nlimbs] {
  r = r;
  a = a;
  r = _mov(r, a);
  r = r;
  return r;
}

//@ ensures \result = if cond then b else a;
inline fn __cmov
( reg mut ptr u64[nlimbs] a
, reg bool cond
, reg const ptr u64[nlimbs] b
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
    
  for i = 0 to nlimbs {
    t = a[i];
    t = b[i] if cond;
    a[i] = t;
  }
    
  return a;
}

fn _cmov
( reg mut ptr u64[nlimbs] a
, reg bool cond
, reg const ptr u64[nlimbs] b
) -> reg ptr u64[nlimbs] {
  a = __cmov(a, cond, b);
  return a;
}

inline fn _cmov_
( reg mut ptr u64[nlimbs] a
, reg bool cond
, reg const ptr u64[nlimbs] b
) -> reg ptr u64[nlimbs] {
  a = a;
  b = b;
  a = _cmov(a, cond, b);
  a = a;
  return a;
}


inline fn __cswap_mask
 ( reg mut ptr u64[nlimbs] x
 , reg mut ptr u64[nlimbs] y
 , reg u64 mask // 0/-1
 ) -> reg ptr u64[nlimbs] , reg ptr u64[nlimbs] {
  reg u64 tmp1, tmp2;
  inline int i;
  for i = 0 to nlimbs {
   tmp1   = x[i];
   tmp1  ^= y[i];
   tmp1  &= mask;
   x[i]  ^= tmp1;
   y[i]  ^= tmp1;
  }

  return x, y;
}

fn _cswap_mask
 ( reg mut ptr u64[nlimbs] x
 , reg mut ptr u64[nlimbs] y
 , reg u64 mask // 0/-1
 ) -> reg ptr u64[nlimbs] , reg ptr u64[nlimbs] {
  x, y = __cswap_mask(x,y,mask);
  return x,y;
}

inline fn _cswap_mask_
 ( reg mut ptr u64[nlimbs] x
 , reg mut ptr u64[nlimbs] y
 , reg u64 mask // 0/-1
 ) -> reg ptr u64[nlimbs] , reg ptr u64[nlimbs] {
  x = x;
  y = y;
  x, y = _cswap_mask(x,y,mask);
  x = x;
  y = y;
  return x, y;
}

inline fn _cswap_cf_
 ( reg mut ptr u64[nlimbs] x
 , reg mut ptr u64[nlimbs] y
 , reg bool cf
 ) -> reg ptr u64[nlimbs] , reg ptr u64[nlimbs] {
  reg u64 mask, tmp1, tmp2;
  inline int i;
  mask = __cf_mask(cf);
  x, y = _cswap_mask_(x, y, mask);
  return x, y;
}

//@ ensures \forall v in \result; v == 0;
inline fn __fill
( reg mut ptr u64[nlimbs] a
, reg u64 x
) -> reg ptr u64[nlimbs] {
  inline int i;
  for i = 0 to nlimbs {
    a[i] = x;
  }
  return a;
}

fn _fill
( reg mut ptr u64[nlimbs] a
, reg u64 x
) -> reg ptr u64[nlimbs] {
  a = __fill(a, x);
  return a;
}

inline fn _fill_
( reg mut ptr u64[nlimbs] a
, reg u64 x
) -> reg ptr u64[nlimbs] {
  a = a; x = x;
  a = __fill(a, x);
  a = a;
  return a;
}

//@ ensures \forall v in \result; v == 0;
inline fn _set0_
( reg mut ptr u64[nlimbs] a
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
  t = 0;
  a = _fill_(a, t);
  return a;
}

inline fn __cfill
( reg mut ptr u64[nlimbs] a
, reg bool b
, reg u64 x
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
  for i = 0 to nlimbs {
    t = a[i];
    t = x if b;
    a[i] = t;
  }
  return a;
}

inline fn __or_mask
( reg mut ptr u64[nlimbs] a
, reg u64 mask
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
  for i = 0 to nlimbs {
    a[i] |= mask;
  }
  return a;
}

fn _or_mask
( reg mut ptr u64[nlimbs] a
, reg u64 mask
) -> reg ptr u64[nlimbs] {
  a = __or_mask(a, mask);
  return a;
}

inline fn _or_mask_
( reg mut ptr u64[nlimbs] a
, reg u64 mask
) -> reg ptr u64[nlimbs] {
  a = a; mask = mask;
  a = _or_mask(a, mask);
  a = a;
  return a;
}

inline fn _set_err_
( reg mut ptr u64[nlimbs] a
, stack u64 _err
) -> reg ptr u64[nlimbs] {
  reg u64 err t;
  err = _err;
  a = _or_mask_(a, err);
  return a;
}

inline fn __and_mask
( reg mut ptr u64[nlimbs] a
, reg u64 mask
) -> reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
  for i = 0 to nlimbs {
    a[i] &= mask;
  }
  return a;
}

fn _and_mask
( reg mut ptr u64[nlimbs] a
, reg u64 mask
) -> reg ptr u64[nlimbs] {
  a = __and_mask(a, mask);
  return a;
}

inline fn _and_mask_
( reg mut ptr u64[nlimbs] a
, reg u64 mask
) -> reg ptr u64[nlimbs] {
  a = a; mask = mask;
  a = _and_mask(a, mask);
  a = a;
  return a;
}


//@ ensures bn(\result) = a + cf*2^(64*k)
inline fn __carrypropU
( reg mut ptr u64[nlimbs] a,
  reg bool cf,
  inline int k
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  for i=k to nlimbs
  { cf, a[i] += 0 + cf; }

  return cf, a;
}

//@ ensures (\result)
//    = a %% 2^(64) + 2^(64) * (a %/ 2^(64) + b %/ 2^(64) + cf)
inline fn __addc1U
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  reg u64 t;
  for i=1 to nlimbs {
    t = b[i];
    cf, a[i] += t + cf;
  }

  return cf, a;
}

fn _addc1U
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  cf, a = __addc1U(a, b, cf);
  return cf, a;
}

inline fn _addc1U_
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  a = a; b = b;
  cf, a = _addc1U(a, b, cf);
  a = a;
  return cf, a;
}
  
/* multi-limb addition (update inplace) */
inline fn _addcU_
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  reg u64 t;

  t = b[0];
  cf, a[0] += t + cf;
  cf, a = _addc1U_(a, b, cf);
  return cf, a;
}

inline fn _addU_
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
) -> reg bool, reg ptr u64[nlimbs]
{
  inline int i;
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] += t;
  cf, a = _addc1U_(a, b, cf);
  return cf, a;
}

inline fn __addc1
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;

  for i=1 to nlimbs { 
   t = a[i];
   cf, t += b[i] + cf;
   r[i] = t;
  }

  return cf, r;
}

fn _addc1
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  cf, r = __addc1(r, a, b, cf);
  return cf, r;
}

inline fn _addc1_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  r = r; a = a; b = b;
  cf, r = _addc1(r, a, b, cf);
  r = r;
  return cf, r;
}

inline fn _add_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg bool, reg ptr u64[nlimbs]
{
  reg bool cf;
  reg u64 t;
  t = a[0];
  cf, t += b[0];
  r[0] = t;
  cf, r = _addc1_(r, a, b, cf);
  return cf, a;
}

inline fn _addc_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs]
{
  reg u64 t;
  t = a[0];
  cf, t += b[0] + cf;
  r[0] = t;
  cf, r = _addc1_(r, a, b, cf);
  return cf, a;
}

/* performs multi-limb subtraction */
inline fn __subc1U
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;

  for i=1 to nlimbs {
   t = b[i];
   cf, a[i] -= t - cf;
  }

  return cf, a;
}

fn _subc1U
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
 cf, a = __subc1U(a, b, cf);
 return cf, a;
}

inline fn _subc1U_
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  a = a; b = b;
  cf, a = _subc1U(a, b, cf);
  a = a;
  return cf, a;
}

inline fn _subU_
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
) -> reg bool, reg ptr u64[nlimbs]
{
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] -= t;
  cf, a = _subc1U_(a, b, cf);
  return cf, a;
}

inline fn _subcU_
( reg mut ptr u64[nlimbs] a
, reg const ptr u64[nlimbs] b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs]
{
  reg u64 t;

  t = b[0];
  cf, a[0] -= t - cf;
  cf, a = _subc1U_(a, b, cf);
  return cf, a;
}

inline fn __subc1
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;

  for i=1 to nlimbs {
   t = a[i];
   cf, t -= b[i] - cf;
   r[i] = t;
  }

  return cf, r;
}

fn _subc1
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  cf, r = __subc1(r, a, b, cf);
  return cf, r;
}

inline fn _subc1_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  r = r; a = a; b = b;
  cf, r = _subc1(r, a, b, cf);
  r = r;
  return cf, r;
}

inline fn _sub_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg bool cf;
  reg u64 t;
  t = a[0];
  cf, t -= b[0];
  r[0] = t;
  cf, r = _subc1_(r, a, b, cf);
  return cf, r;
}
 
inline fn _subc_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;
  t = a[0];
  cf, t -= b[0] - cf;
  r[0] = t;
  cf, r = _subc1_(r, a, b, cf);
  return cf, r;
}
 

/* comparison */
inline fn __ltc1_cf
( reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool {
  inline int i;
  reg u64 t;

  for i=1 to nlimbs {
   t = a[i];
   cf, t -= b[i] - cf;
  }

  return cf;
}

fn _ltc1_cf
( reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool {
  cf = __ltc1_cf(a, b, cf);
  return cf;
}

inline fn _ltc1_cf_
( reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool {
  a = a; b = b;
  cf = _ltc1_cf(a, b, cf);
  return cf;
}

inline fn _lt_cf_
( reg const ptr u64[nlimbs] a b
) -> reg bool {
  inline int i;
  reg bool cf;
  reg u64 t;

  t = a[0];
  cf, t -= b[0];
  cf = _ltc1_cf_(a, b, cf);
  return cf;
}

inline fn _ltc_cf_
( reg const ptr u64[nlimbs] a b
, reg bool cf
) -> reg bool {
  inline int i;
  reg u64 t;

  t = a[0];
  cf, t -= b[0] - cf;
  cf = _ltc1_cf_(a, b, cf);
  return cf;
}

/* Negation (two's complement) */
inline fn __negc1U
( reg mut ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;

  for i=1 to nlimbs {
   t = 0;
   cf, t -= a[i] - cf;
   a[i] = t;
  }

  return cf, a;
}

fn _negc1U
( reg mut ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  cf, a = __negc1U(a, cf);
  return cf, a;
}

inline fn _negc1U_
( reg mut ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  a = a;
  cf, a = _negc1U(a, cf);
  a = a;
  return cf, a;
}

inline fn _negU_
( reg mut ptr u64[nlimbs] a
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg bool cf;
  reg u64 t;

  t = 0;
  cf, t -= a[0];
  a[0] = t;
  cf, a = _negc1U_(a, cf);
  return cf, a;
}

inline fn _negcU_
( reg mut ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;

  t = 0;
  cf, t -= a[0] - cf;
  a[0] = t;
  cf, a = _negc1U_(a, cf);
  return cf, a;
}


inline fn __negc1
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  inline int i;
  reg u64 t;

  for i=1 to nlimbs {
   t = 0;
   cf, t -= a[i] - cf;
   r[i] = t;
  }

  return cf, r;
}

fn _negc1
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  cf, r = __negc1(r, a, cf);
  return cf, r;
}

inline fn _negc1_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  r = r; a = a;
  cf, r = _negc1(r, a, cf);
  r = r;
  return cf, r;
}

inline fn _neg_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg bool, reg ptr u64[nlimbs] {
  reg bool cf;
  reg u64 t;

  t = 0;
  cf, t -= a[0];
  r[0] = t;
  cf, r = _negc1_(r, a, cf);
  return cf, a;
}

inline fn _negc_
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[nlimbs] a
, reg bool cf
) -> reg bool, reg ptr u64[nlimbs] {
  reg u64 t;

  t = 0;
  cf, t -= a[0] - cf;
  r[0] = t;
  cf, r = _negc1_(r, a, cf);
  return cf, a;
}

inline fn _cnegU_
( reg mut ptr u64[nlimbs] a
, reg u64 cond
) -> reg u64[nlimbs] {
  reg bool cf;
  stack u64[nlimbs] _x;
  reg ptr u64[nlimbs] x;
  x = _x;
  _, x = _neg_(x, a);
  cf = __mask_cf(cond);
  a = _cmov_(a, cf, x);
  return a;
}


/* CONDITIONAL-ADD */
//@ ensures bn(res) == if cf then bn(x)+bn(y) else bn(x);
inline fn _caddU_
( reg mut ptr u64[nlimbs] x
, reg bool cf
, reg ptr u64[nlimbs] y
) -> reg ptr u64[nlimbs]
{
  inline int i;
  reg u64 t mask t0;
  stack u64[nlimbs] _tmp;
  reg ptr u64[nlimbs] tmp;

  tmp = _tmp;
  tmp = _mov_(tmp,y);
  mask = __cf_mask(cf);
  tmp = _and_mask_(tmp, mask);
  _, x = _addU_(x, tmp);

  return x;
}


/** 
  * MULTIPLICATION: product-scanning
  */

// regs: params(5) + 3 = 8
inline fn __muln_innerloop
( reg u64[3] x
, inline int k istart iend
, reg ptr u64[nlimbs] a b
) -> reg u64[3] {
  reg u64 t1, t0;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    t0 = a[i];
    t1, t0 = t0 * b[j];
    x = __addacc3(x, t1, t0, k);
  }
  return x;
}

// regs: params(3) + call(3) + 3(+2) = 9
inline fn __muln
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;


  t0 = a[0];
  t1, t0 = t0 * b[0];
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
  for k = 1 to nlimbs {
    x = __muln_innerloop(x, k, 0, k+1, a, b);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = nlimbs to 2*nlimbs-1 {
    x = __muln_innerloop(x, k, k-nlimbs+1, nlimbs, a, b);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*nlimbs-1] = x[(2*nlimbs-1) % 3];
  return r;
}

// regs: params(3) + call(6) = 9
fn _muln
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs] {
  r = __muln(r, a, b);
  return r;
}

inline fn _muln_
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs] {
  r = r; a = a; b = b;
  r = _muln(r, a, b);
  r = r;
  return r;
}


// regs: params(4) + 2 = 6 
inline fn __sqrn_innerloop
( reg u64[3] x
, inline int k istart iend
, reg const ptr u64[nlimbs] a
) -> reg u64[3] {
  reg u64 ti, tj;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    ti = a[i];
    tj = a[j];
    x = __addacc3x2(x, ti, tj, k);
  }
  return x;
}

inline fn __sqrn
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[2*nlimbs] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;

  t0 = a[0];
  t1, t0 = t0 * t0;
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;

  for k = 1 to nlimbs {
    x = __sqrn_innerloop(x, k, 0, (k+1)/2, a);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = __addacc3(x, t1, t0, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = nlimbs to 2*nlimbs-1 {
    x = __sqrn_innerloop(x, k, k-nlimbs+1, (k+1)/2, a);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = __addacc3(x, t1, t0, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*nlimbs-1] = x[(2*nlimbs-1) % 3];
  return r;
}

fn _sqrn
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[2*nlimbs] {
  r = __sqrn(r, a);
  return r;
}

inline fn _sqrn_
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[2*nlimbs] {
  r = r; a = a;
  r = _sqrn(r, a);
  r = r;
  return r;
}


/* x-P if P<=x else x
   (remark: [x;lastbit] < 2*P)
 */
inline fn _cminusP_
 ( reg mut ptr u64[nlimbs] x   //
 , reg const ptr u64[nlimbs] mP  // R-P
 , reg u64 lastbit         // 0/1
 ) -> reg ptr u64[nlimbs]  // [x,lastbit]<P ? x : [x,lastbit]-P
{
  inline int i;
  reg bool _cf;
  stack u64[nlimbs] _tmp;
  reg ptr u64[nlimbs] tmp;

  tmp = _tmp;
  tmp = _mov_(tmp, x);
  _cf, tmp = _addU_(tmp, mP);

  _, lastbit += 0 + _cf;
  _, _cf, _, _, _, _ = #NEG(lastbit);

  x = _cmov_(x, _cf, tmp);
  return x;
}

// ////////////////////////////////////
// regs: params(3) + call(3) + 3 = 9
inline fn __mont_redM
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[2*nlimbs] a
, stack u64[nlimbs] _P
, stack u64[nlimbs] _mP
, stack u64 _U0
) -> reg ptr u64[nlimbs] {
  inline int k;
  reg bool cf;
  reg ptr u64[nlimbs] P mP;
  reg u64 t t0 t1 zero p0 lastbit;
  reg u64[3] x;

//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
//  _, _, _, _, _, x[1] = #set0();
  x[1] = 0;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;

  for k = 0 to nlimbs {
    P = _P;
    x = __muln_innerloop(x, k, 0, k, r, P); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = __addacc3(x, zero, t0, k);
    t0 = x[k % 3];
    _, t0 = t0 * _U0;
    r[k] = t0;
    t1, t0 = t0 * _P[0];
    x = __addacc3(x, t1, t0, k);
  }
  for k = nlimbs to 2*nlimbs-1 {
    P = _P;
    x = __muln_innerloop(x, k, k-nlimbs+1, nlimbs, r, P); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = __addacc3(x, zero, t0, k);
    t0 = x[k % 3];
    r[k-nlimbs] = t0;
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
  }

  lastbit = 0;
  cf, x[(2*nlimbs-1) % 3] += a[2*nlimbs-1];
  _, lastbit += 0 + cf;

  r[nlimbs-1] = x[(2*nlimbs-1) % 3];

  mP = _mP;
  r = _cminusP_(r, mP, lastbit);
  return r;
}




/* pack two bignums into a double bignum */
inline fn __pack2
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] lo hi
) -> reg ptr u64[2*nlimbs]
{
  inline int i;
  reg u64 t;

  for i = 0 to nlimbs {
    t = lo[i];
    r[i] = t;
  }
  for i = 0 to nlimbs {
    t = hi[i];
    r[nlimbs+i] = t;
  }

  return r;
}

fn _pack2
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] lo hi
) -> reg ptr u64[2*nlimbs] {
  r = __pack2(r, lo, hi);
  return r;
}

inline fn _pack2_
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] lo hi
) -> reg ptr u64[2*nlimbs] {
  r = r; lo = lo; hi = hi;
  r = __pack2(r, lo, hi);
  r = r;
  return r;
}
