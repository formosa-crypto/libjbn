/* (emulation of https://github.com/jasmin-lang/jasmin/issues/519)


modsignature {
  int nlimbs;		// num. limbs
  u64[limbs] glob_exp0;
  u64[nlimbs] glob_Pm2;
  fn fun_red ( reg const ptr u64[2*nlimbs]
             , reg mut ptr u64[nlimbs)
             ) -> reg ptr u64[nlimbs]
}

require "bn_base" as "BN"
  with { nlimbs = nlimbs; }

*/

from MJazz require "BN_bn_base.jinc" // BN qualified

inline fn ${qual}__chk_bnds
( reg const ptr u64[${nlimbs}] a
, stack u64 err
) -> stack u64 {
 reg ptr u64[${nlimbs}] P;
 reg bool cf;
 reg u64 t;
 P = ${glob_P};
 cf = BN__lt_cf(a, P);
 t = BNUTIL__cf_mask(cf);
 t = #NOT_64(t);
 err |= t;
 return err;
}

inline fn ${qual}__addmU
 ( reg mut ptr u64[${nlimbs}] a
 , reg const ptr u64[${nlimbs}] b
 ) -> reg ptr u64[${nlimbs}]
{
  reg bool cf;
  reg u64 lastbit;
  reg ptr u64[${nlimbs}] tmp;

  cf, a = ${qualBN}__addU(a, b);

  lastbit = 0;
  _, lastbit += 0 + cf;
  tmp = ${glob_mP};
  a = ${qualBN}__cminusP(lastbit, a, tmp);
  return a;
}

/* Modular addition */
fn ${qual}_addmU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
  a = ${qual}__addmU(a, b);
 return a;
}

// ////////////////////////////////////

inline fn ${qual}__submU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
 reg bool cf;
 reg ptr u64[${nlimbs}] tmp;
 cf, a = ${qualBN}__subU(a, b);
 tmp = ${glob_P};
 a = ${qualBN}__caddU(cf, a, tmp);
 return a;
}

/* Modular subtraction */
fn ${qual}_submU
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
 a = ${qual}__submU(a, b);
 return a;
}

/* Modular multiplication */
fn ${qual}_mulm
( reg ptr u64[${nlimbs}] a b
, reg mut ptr u64[${nlimbs}] r
) -> reg ptr u64[${nlimbs}] {
  stack u64[2*${nlimbs}] _tmp;
  reg ptr u64[2*${nlimbs}] tmp;

  tmp = _tmp;
  tmp = ${qualBN}__muln(a, b, tmp);
  r = ${fun_red}(tmp, r);
  return r;
}

// ////////////////////////////////////

fn ${qual}_mulmU // update inplace
( reg mut ptr u64[${nlimbs}] a
, reg ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
  stack u64[2*${nlimbs}] _tmp;
  reg ptr u64[2*${nlimbs}] tmp;
  tmp = _tmp;
  tmp = ${qualBN}__muln(a, b, tmp);
  tmp = tmp; a = a;
  a = ${fun_red}(tmp, a);
  a = a;
  return a;
}

// ////////////////////////////////////

fn ${qual}_sqrm
( reg ptr u64[${nlimbs}] a
, reg mut ptr u64[${nlimbs}] r
) -> reg ptr u64[${nlimbs}] {
  stack u64[2*${nlimbs}] _tmp;
  reg ptr u64[2*${nlimbs}] tmp;

  tmp = _tmp;
  tmp = ${qualBN}__sqrn(a, tmp);
  tmp = tmp; a = a;
  r = ${fun_red}(tmp, r);
  a = a;
  return r;
}

// ////////////////////////////////////

fn ${qual}_sqrmU // update inplace
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  stack u64[2*${nlimbs}] _tmp;
  reg ptr u64[2*${nlimbs}] tmp;
  tmp = _tmp;
  tmp = ${qualBN}__sqrn(a, tmp);
  a = ${fun_red}(tmp, a);
  return a;
}

// ////////////////////////////////////

/*
// ???obs: import without qualifier -- declarations
// are added to the "current" scope
// ???obs2: alternative: reuse qualifier

require "bn_exp.jinc" // as FPM
 with { nlimbs = nlimbs;
        nlimbsexp = nlimbs;
        glob_exp0 = glob_exp0;
        fun_mulU = FPM_mulmU;
        fun_sqrU = FPM_sqrmU;
      }
*/
from MJazz require "${qualBNE}_bn_exp.jinc" 


/* Modular Inversion (fermat) */
inline fn ${qual}__invm
( reg const ptr u64[${nlimbs}] a
, reg mut ptr u64[${nlimbs}] r
) -> reg ptr u64[${nlimbs}] {
  /* a^{p-2} */
  reg ptr u64[${nlimbsexp}] Pm2;
  Pm2 = ${glob_Pm2};
  r = ${qualBNE}_expm_noct(a, Pm2, r);
  return r;
}

