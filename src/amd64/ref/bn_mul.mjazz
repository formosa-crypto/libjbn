modsignature { param int nlimbs; }

from Libjbn require "bn_util.jinc"

from Libjbn require "bn_base.mjazz"
  with { nlimbs = nlimbs; }


/******************************************************************
                      OPERAND-SCANNING
*******************************************************************/
inline fn __mul1
( reg mut ptr u64[2*nlimbs] r
, reg u64 a
, reg const ptr u64[nlimbs] b
) -> reg u64, reg bool, reg bool, reg u64[2*nlimbs]
{
  inline int i;
  reg bool of, cf;
  reg u64 _zero, lo, hi;
  reg u64[nlimbs+1] rr; // at most 2 alive

  of, cf, _, _, _, _zero = #set0();

  rr[1], rr[0] = #MULX ( a, b[0] );
  r[0] = rr[0]; // kill rr[0]
  for i = 1 to nlimbs {
    rr[i+1], lo = #MULX ( a, b[i] );
    cf, rr[i] = #ADCX ( rr[i], lo, cf );
    r[i] = rr[i]; // kill rr[i]
  }

  cf, rr[nlimbs] = #ADCX ( rr[nlimbs], _zero, cf );
  r[nlimbs] = rr[nlimbs];
  // cf = 0

  return _zero, of, cf, r;
}


/* multiplies a (shifted) scalar by a reg array (remaining iterations of mul) */
/* REGS (params + workspace):  */
inline fn __mul1acc
( inline int k
, reg mut ptr u64[2*nlimbs] r
, reg u64 a
, reg const ptr u64[nlimbs] b
, reg u64 _zero // should be set to 0
, reg bool of cf // should be set to 0
) -> reg u64, reg bool, reg bool, reg u64[2*nlimbs]
{
  inline int i;
  reg u64 ak hi lo;
  reg u64[nlimbs+1] rr; // at most 2 alive

  rr[0] = r[k];
  for i = 0 to nlimbs-1 {
    rr[i+1] = r[k+i+1];
    hi, lo = #MULX ( a, b[i] ); 
    of, rr[i] = #ADOX ( rr[i], lo, of );
    r[k+i] = rr[i]; // kill rr[i]
    cf, rr[i+1] = #ADCX ( rr[i+1], hi, cf );
  }

  rr[nlimbs], lo = #MULX ( a, b[nlimbs-1] ); // a is now dead!
  of, rr[nlimbs-1] = #ADOX ( rr[nlimbs-1], lo, of );
  r[k+nlimbs-1] = rr[nlimbs-1]; // kill rr[nlimbs-1]

  cf, rr[nlimbs] = #ADCX ( rr[nlimbs], _zero, cf);
  of, rr[nlimbs] = #ADOX ( rr[nlimbs], _zero, of);
  r[k+nlimbs] = rr[nlimbs];
  // cf = 0, of = 0

  return _zero, of, cf, r;
}


/* Operand-scanning multiplication (first arg. as a reg_ptr) */
fn _os_muln
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b //reg u64 fptr,
) -> reg ptr u64[2*nlimbs]
{
  inline int i;
  reg bool of cf;
  reg u64 _zero ai;

  ai = a[0];

  _zero, of, cf, r = __mul1(r, ai, b);

  for i = 1 to nlimbs {
    ai = a[i];
    _zero, of, cf, r = __mul1acc(i, r, ai, b, _zero, of, cf);
  }

  return r;
}

inline fn _os_muln_
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs]
{
  r = r; a = a; b = b;
  r = _muln_os(r, a, b);
  r = r;
  return r;
}


inline fn _os_kmuln_
( reg mut ptr u64[2*nlimbs] r
, reg mut ptr u64[nlimbs] tmp
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs], reg ptr u64[nlimbs]
{
  r = _muln_os_( r, a, b );
  return r, tmp;
}


/*
export fn bn_muln_os(reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b;
  stack u64[2*nlimbs] _r;
  reg ptr u64[nlimbs] a b;
  reg ptr u64[2*nlimbs] r;

  a = _a;
  a = __load(a,ap);
  b = _b;
  b = __load(b,bp);
  r = _r;
  r = _muln_os_(r, a, b);
  __store2(rp, r);
}
*/

/******************************************************************
                      PRODUCT-SCANNING
*******************************************************************/


// regs: params(5) + 3 = 8
inline fn __muln_innerloop
( reg u64[3] x
, inline int k istart iend
, reg ptr u64[nlimbs] a b
) -> reg u64[3] {
  reg u64 t1, t0;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    t0 = a[i];
    t1, t0 = t0 * b[j];
    x = __addacc3(x, t1, t0, k);
  }
  return x;
}

// regs: params(3) + call(3) + 3(+2) = 9
inline fn __ps_muln
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;


  t0 = a[0];
  t1, t0 = t0 * b[0];
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
  for k = 1 to nlimbs {
    x = __muln_innerloop(x, k, 0, k+1, a, b);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = nlimbs to 2*nlimbs-1 {
    x = __muln_innerloop(x, k, k-nlimbs+1, nlimbs, a, b);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*nlimbs-1] = x[(2*nlimbs-1) % 3];
  return r;
}

// regs: params(3) + call(6) = 9
fn _ps_muln
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs] {
  r = __muln_ps(r, a, b);
  return r;
}

inline fn _ps_muln_
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[2*nlimbs] {
  r = r; a = a; b = b;
  r = _ps_muln(r, a, b);
  r = r;
  return r;
}

inline fn _ps_kmuln_
( reg mut ptr u64[2*nlimbs] r
, reg mut ptr u64[nlimbs] tmp
, reg const ptr u64[nlimbs] a b
) -> reg ptr u64[nlimbs], reg ptr u64[2*nlimbs]
{
  r = _ps_muln_( r, a, b );
  return tmp, r;
}

/*
export fn bn_muln_ps(reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b;
  stack u64[2*nlimbs] _r;
  reg ptr u64[nlimbs] a b;
  reg ptr u64[2*nlimbs] r;

  a = _a;
  a = __load(a,ap);
  b = _b;
  b = __load(b,bp);
  r = _r;
  r = _muln_ps_(r, a, b);
  __store2(rp, r);
}
*/



// regs: params(4) + 2 = 6 
inline fn __sqrn_innerloop
( reg u64[3] x
, inline int k istart iend
, reg const ptr u64[nlimbs] a
) -> reg u64[3] {
  reg u64 ti, tj;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    ti = a[i];
    tj = a[j];
    x = __addacc3x2(x, ti, tj, k);
  }
  return x;
}

inline fn __ps_sqrn
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[2*nlimbs] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;
  reg bool cf;

  t0 = a[0];
  t1, t0 = t0 * t0;
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;

  for k = 1 to nlimbs {
    x = __sqrn_innerloop(x, k, 0, (k+1)/2, a);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = __addacc3(x, t1, t0, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = nlimbs to 2*nlimbs-1 {
    x = __sqrn_innerloop(x, k, k-nlimbs+1, (k+1)/2, a);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = __addacc3(x, t1, t0, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*nlimbs-1] = x[(2*nlimbs-1) % 3];
  return r;
}

fn _ps_sqrn
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[2*nlimbs] {
  r = __sqrn(r, a);
  return r;
}

inline fn _ps_sqrn_
( reg mut ptr u64[2*nlimbs] r
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[2*nlimbs] {
  r = r; a = a;
  r = _sqrn(r, a);
  r = r;
  return r;
}

inline fn _ps_ksqrn_
( reg mut ptr u64[2*nlimbs] r
, reg mut ptr u64[nlimbs] tmp
, reg const ptr u64[nlimbs] a
) -> reg ptr u64[nlimbs], reg ptr u64[2*nlimbs]
{
  r = _ps_sqrn_( r, a );
  return tmp, r;
}


// ////////////////////////////////////
// regs: params(3) + call(3) + 3 = 9
inline fn __mont_redM
( reg mut ptr u64[nlimbs] r
, reg const ptr u64[2*nlimbs] a
, stack u64[nlimbs] _P
, stack u64[nlimbs] _mP
, stack u64 _U0
) -> reg ptr u64[nlimbs] {
  inline int k;
  reg bool cf;
  reg ptr u64[nlimbs] P mP;
  reg u64 t t0 t1 zero p0 lastbit;
  reg u64[3] x;

//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
//  _, _, _, _, _, x[1] = #set0();
  x[1] = 0;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;

  for k = 0 to nlimbs {
    P = _P;
    x = __muln_innerloop(x, k, 0, k, r, P); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = __addacc3(x, zero, t0, k);
    t0 = x[k % 3];
    _, t0 = t0 * _U0;
    r[k] = t0;
    t1, t0 = t0 * _P[0];
    x = __addacc3(x, t1, t0, k);
  }
  for k = nlimbs to 2*nlimbs-1 {
    P = _P;
    x = __muln_innerloop(x, k, k-nlimbs+1, nlimbs, r, P); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = __addacc3(x, zero, t0, k);
    t0 = x[k % 3];
    r[k-nlimbs] = t0;
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
  }

  lastbit = 0;
  cf, x[(2*nlimbs-1) % 3] += a[2*nlimbs-1];
  _, lastbit += 0 + cf;

  r[nlimbs-1] = x[(2*nlimbs-1) % 3];

  mP = _mP;
  r = _cminusP_(r, mP, lastbit);
  return r;
}


