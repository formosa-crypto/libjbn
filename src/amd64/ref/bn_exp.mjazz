/*
   GENERIC EXPONENTIATION

BN_EXP_FNS = _expm_noct_ _expmU_noct_ _expm_ _expmU_

*/

/*
modsignature {
  int nlimbs;		// num. limbs
  int nlimbsexp;	// num. limbs
  u64[nlimbs] glob_exp0;
  fn fun_mulU ( reg mut ptr u64[nlimbs]
              , reg const ptr u64[nlimbs)
              ) -> reg ptr u64[nlimbs]
  fn fun_sqrU ( reg mut ptr u64[nlimbs]
              ) -> reg ptr u64[nlimbs]
}

require "bn_base.jinc" as "BN"
  with { nlimbs = nlimbs; }

*/
from MJazz require "${qualBN}_bn_base.jinc"

// ////////////////////////////////////

/* Modular exponentiation
  obs: naive square-multiply algorithm. Not Constant-Time!!!
  (good enough to use with public exponents, such as in inversion) */
fn ${qual}_expm_noct
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbsexp}] b
) -> reg ptr u64[${nlimbs}] {
  inline int j;
  reg u64 t;
  reg bool cf zf;
  reg ptr u64[${nlimbs}] x;
  stack u64 _k;
  stack u64[${nlimbs}] _x;
  stack ptr u64[${nlimbsexp}] _b;

  _b = b;
  x = _x;
  x = ${qualBN}_mov_(x, a);
  _x = x;

  for j = 0 to ${nlimbsexp} {
    b = _b;
    t = b[(int) j];
    _k = 64;
    while {
      _, cf, _, _, _, t = #SHR(t, 1);
      x = _x;
      if (cf) {
        r = ${fun_mulU}(r, x);
      }
      x = ${fun_sqrU}(x);
      _x = x;
      _, _, _, zf, _k = #DEC(_k);
    } (!zf)
  }
  return r;
}

inline fn ${qual}_expm_noct_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbsexp}] b
) -> reg ptr u64[${nlimbs}] {
  reg ptr u64[${nlimbs}] exp0;
  exp0 = ${glob_exp0};
  r = ${qualBN}_mov_(r, exp0);
  a = a; b = b;
  r = ${qual}_expm_noct(r, a, b);
  r = r;
  return r;
}

inline fn ${qual}_expmU_noct_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbsexp}] b
) -> reg ptr u64[${nlimbs}] {
  stack u64[${nlimbs}] _tmp;
  reg ptr u64[${nlimbs}] tmp exp0;
  tmp = _tmp;
  tmp = ${qualBN}_mov_(tmp, a);
  exp0 = ${glob_exp0};
  a = ${qualBN}_mov_(a, exp0);
  a = ${qual}_expm_noct_(a, tmp, b);
  return a;
}

/* Modular exponentiation (constant-time) */
fn ${qual}_expm
( reg mut ptr u64[${nlimbs}] x0 x1
, reg const ptr u64[${nlimbsexp}] b
) -> reg ptr u64[${nlimbs}], reg ptr u64[${nlimbs}] {
  inline int j;
  reg u64 t mask;
  stack u64 _k _mask _t;
  reg bool cf zf;
  stack ptr u64[${nlimbsexp}] _b;

  _b = b;

  for j = ${nlimbsexp}-1 downto -1  {
    b = _b;
    t = b[(int) j];
    _k = 64;
    while {
      _, cf, _, _, _, t = #SHL(t, 1);
      _t = t;
      mask = ${qualUTIL}__cf_mask(cf);
      x0, x1 = ${qualBN}_cswap_mask_(x0, x1, mask);
      _mask = mask;
      x1 = ${fun_mulU}(x1, x0);
      x0 = ${fun_sqrU}(x0);
      mask = _mask;
      x0, x1 = ${qualBN}_cswap_mask_(x0, x1, mask);
      t = _t;
      _, _, _, zf, _k = #DEC(_k);
    } (!zf)
  }
  return x0, x1;
}

inline fn ${qual}_expm_
( reg mut ptr u64[${nlimbs}] x0
, reg const ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbsexp}] b
) -> reg ptr u64[${nlimbs}] {
  stack u64[${nlimbs}] _x1;
  reg ptr u64[${nlimbs}] x1 exp0;
  x1 = _x1;
  x1 = ${qualBN}_mov_(x1, a);
  exp0 = ${glob_exp0};
  x0 = ${qualBN}_mov_(x0, exp0);
  b = b;
  x0, _ = ${qual}_expm(x0, x1, b);
  x0 = x0;
  return x0;
}

inline fn ${qual}_expmU_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbsexp}] b
) -> reg ptr u64[${nlimbs}] {
  stack u64[${nlimbs}] _x1;
  reg ptr u64[${nlimbs}] x1 exp0;
  x1 = _x1;
  x1 = ${qualBN}_mov_(x1, a);
  exp0 = ${glob_exp0};
  a = ${qualBN}_mov_(a, exp0);
  b = b;
  a, _ = ${qual}_expm(a, x1, b);
  a = a;
  return a;
}
