modsignature {
  param int nlimbs;		// num. limbs
  global u64[nlimbs] glob_P;	// modulus (M)
  global u64[nlimbs] glob_mP;	// minus M (2^(nlimbs*64) - M )
  global u64 glob_P0i;		// inverse of M[0]
  global u64[nlimbs] glob_Pm2;	// P-2
  global u64[nlimbs] glob_exp0;	// OneM (one in Montgomery form)
  global u64[nlimbs] glob_RM;	// RM (R in Montgomery form)
}

from Libjbn require "bn_base.mjazz" as BN with { nlimbs = nlimbs; }

from Libjbn require "fp_mont.mjazz" as FPM
 with { nlimbs = nlimbs;
        glob_P = glob_P;
        glob_mP = glob_mP;
        glob_Pi0 = Pi0;
        glob_Pm2 = glob_Pm2;
	glob_exp0 = glob_exp0;
	glob_RM = glob_RM;
 }


export fn fp_add(reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b;
  reg ptr u64[nlimbs] a b;

  a = _a;
  b = _b;
  a = BN._load_(a,ap);
  b = BN._load_(b,bp);
  a = FPM._addmU_(a, b);
  BN._store_(rp, a);
}


export fn fp_sub( reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b;
  reg ptr u64[nlimbs] a b;

  a = _a;
  b = _b;
  a = BN._load_(a,ap);
  b = BN._load_(b,bp);
  a = FPM._submU_(a, b);
  BN._store_(rp, a);
}

export fn fp_mul(reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b _r;
  reg ptr u64[nlimbs] a b r;

  a = _a;
  b = _b;
  a = BN._load_(a,ap);
  b = BN._load_(b,bp);
  r = _r;
  r = FPM._mulm_(r, a, b);
  BN._store_(rp, r);
}

export fn fp_sqr(reg u64 rp ap)
{
  stack u64[nlimbs] _a _r;
  reg ptr u64[nlimbs] a r;

  a = _a;
  a = BN._load_(a,ap);
  r = _r;
  r = FPM._sqrm_(r, a);
  BN._store_(rp, r);
}

export fn fp_exp_noct(reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b _r;
  reg ptr u64[nlimbs] a b r;
  stack u64 _rp;

  _rp = rp;
  a = _a;
  a = BN._load_(a,ap);
  b = _b;
  b = BN._load_(b,bp);
  r = _r;
  r = FPM._expm_noct_(r, a, b);
  rp = _rp;
  BN._store_(rp, r);
}

export fn fp_exp(reg u64 rp ap bp)
{
  stack u64[nlimbs] _a _b _r;
  reg ptr u64[nlimbs] a b r;
  stack u64 _rp;

  _rp = rp;
  a = _a;
  a = BN._load_(a,ap);
  b = _b;
  b = BN._load_(b,bp);
  r = _r;
  r = FPM._expm_(r, a, b);
  rp = _rp;
  BN._store_(rp, r);
}

export fn fp_inv(reg u64 rp ap)
{
  stack u64[nlimbs] _a _r;
  reg ptr u64[nlimbs] a r;
  stack u64 _rp;

  _rp = rp;
  a = _a;
  a = BN._load_(a,ap);
  r = _r;
  r = FPM._invm_(r, a);
  rp = _rp;
  BN._store_(rp, r);
}

export fn fp_toM(reg u64 rp ap)
{
  stack u64[nlimbs] _a;
  reg ptr u64[nlimbs] a;
  stack u64 _rp;

  _rp = rp;
  a = _a;
  a = BN._load_(a,ap);
  a = FPM._toM_(a);
  rp = _rp;
  BN._store_(rp, a);
}

export fn fp_fromM(reg u64 rp ap)
{
  stack u64[nlimbs] _a;
  reg ptr u64[nlimbs] a;
  stack u64 _rp;

  _rp = rp;
  a = _a;
  a = BN._load_(a,ap);
  a = FPM._fromM_(a);
  rp = _rp;
  BN._store_(rp, a);
}
