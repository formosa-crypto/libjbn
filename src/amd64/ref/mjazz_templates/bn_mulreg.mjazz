/* This file is indeed a template for a pyhton prototype
   intended to emulate and exercise the "Parametric Modules"
   feature propose in https://github.com/jasmin-lang/jasmin/issues/519.

BN_MUL_FNS = 

*/

//modsignature { param int nlimbs; }


/******************************************************************
             OPERAND-SCANNING (second arg. in registers)
*******************************************************************/
/* REGS (params + workspace): (1+nlimbs) + (nlimbs+2) */
inline fn ${qual}__mul1_reg
( reg u64 a,
  reg u64[${nlimbs}] b
) -> reg u64, reg bool, reg bool, reg u64[2*${nlimbs}]
{
  inline int i;
  reg bool of, cf;
  reg u64 _zero, lo;
  reg u64[2*${nlimbs}] r;

  of, cf, _, _, _, _zero = #set0();

  r[1], r[0] = #MULX ( a, b[0] );

  for i = 1 to ${nlimbs} {
    r[i+1], lo = #MULX ( a, b[i] );
    cf, r[i] = #ADCX ( r[i], lo, cf );
  }

_zero = 0;
  cf, r[${nlimbs}] = #ADCX ( r[${nlimbs}], _zero, cf );
  // cf = 0

  return _zero, of, cf, r;
}


/* multiplies a (shifted) scalar by a reg array (remaining iterations of mul) */
/* REGS (params + workspace):  */
inline fn ${qual}__mul1acc_reg
( inline int k,
  reg u64 a,
  reg u64[${nlimbs}] b,
  reg u64[2*${nlimbs}] r,
  reg u64 _zero, // should be set to 0
  reg bool of cf // should be set to 0
) -> reg u64, reg bool, reg bool, reg u64[2*${nlimbs}]
{
  inline int i;
  reg u64 hi lo;

  for i = 0 to ${nlimbs}-1 {
    hi, lo = #MULX ( a, b[i] ); 
    of, r[k+i] = #ADOX ( r[k+i], lo, of );
    cf, r[k+i+1] = #ADCX ( r[k+i+1], hi, cf );
  }

  r[${nlimbs}+k], lo = #MULX ( a, b[${nlimbs}-1] ); // a is now dead!
  of, r[${nlimbs}+k-1] = #ADOX ( r[${nlimbs}+k-1], lo, of );

_zero = 0;
  cf, r[${nlimbs}+k] = #ADCX ( r[${nlimbs}+k], _zero, cf);
  of, r[${nlimbs}+k] = #ADOX ( r[${nlimbs}+k], _zero, of);
  // cf = 0, of = 0

  return _zero, of, cf, r;
}


/* Operand-scanning multiplication (first arg. as a reg_ptr) */
fn ${qual}_os_muln_reg
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b //reg u64 fptr,
) -> reg ptr u64[2*${nlimbs}]
{
  inline int i;
  reg bool of cf;
  reg u64 _zero ai;
  reg u64[${nlimbs}] rb;
  reg u64[2*${nlimbs}] rr; // only ${nlimbs} live!

  ai = a[0];

  for i = 0 to ${nlimbs} { rb[i] = b[i]; }

  _zero, of, cf, rr = ${qual}__mul1_reg(ai, rb);
  r[0] = rr[0];

  for i = 1 to ${nlimbs} {
    ai = a[i];
    _zero, of, cf, rr = ${qual}__mul1acc_reg(i, ai, rb, rr, _zero, of, cf);
    r[i] = rr[i];
  }

  for i = ${nlimbs} to 2*${nlimbs} { r[i] = rr[i]; }
  return r;
}

inline fn ${qual}_os_muln_reg_
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg ptr u64[2*${nlimbs}]
{
  r = r; a = a; b = b;
  r = ${qual}_os_muln_reg(r, a, b);
  r = r;
  return r;
}

/*
export fn ${qual}bn_muln_reg(reg u64 rp ap bp)
{
  stack u64[${nlimbs}] _a _b;
  stack u64[2*${nlimbs}] _r;
  stack u64 _rp;
  reg ptr u64[${nlimbs}] a b;
  reg ptr u64[2*${nlimbs}] r;

_rp = rp;
  a = _a;
  a = ${qual}__load(a,ap);
  b = _b;
  b = ${qual}__load(b,bp);
  r = _r;
  r = ${qual}_os_muln_reg_(r, a, b);
rp = _rp;
  ${qual}__store2(rp, r);
}
*/


// TODO: add "sqrn" variants
/* 4limbs: (max supported!)
 7:  6:  5:  4:  3:  2:  1:  0:
                 d   c   b   a
                 d   c   b   a
--------------------------------
                2ad 2ac 2ab  aa    (5) // kills a
            2bd 2bc  bb            (3+4->2) // obs: saves bd,bc; kills bb+b
        2cd  cc         (+2)       (2+2->1)
     dd                            (--)
--------------------------------
 xx  xx  xx  xx  xx  xx  xx  xx
*/
