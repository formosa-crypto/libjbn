/* This file is indeed a template for a pyhton prototype
   intended to emulate and exercise the "Parametric Modules"
   feature propose in https://github.com/jasmin-lang/jasmin/issues/519.

BN_BASE_FNS = _load_ _store_ _eq_zf_ _eq_ _test0_zf_ _test0_ __copy _mov_ _cmov_ _cswap_mask_ _cswap_cf_ _fill_ _set0_ __cfill _or_mask_ _and_mask_ _set_err_ __carrypropU _addcU_ _addU_ _addc_ _add_ _subcU_ _subU_ _subc_ _sub_ _lt_cf_ _ltc_cf_ _negU_ _negcU_ _neg_ _negc_ _cnegU_ _caddU_ _muln_ _sqrn_ _cminusP_ __mont_redM _pack2_

*/

/*
modsignature { int nlimbs; }
*/

/*
   GENERIC CODE (parametric on the number of limbs)

   Name Conventions:
     _* <- local (non-exported) jasmin functions
     __* <- inlined functions


*/

//require "bn_util.jinc" // as "BN"
require "${qualUTIL}_bn_util.jinc"

/* Loads BN from memory
 */
inline fn ${qual}__load
( reg mut ptr u64[${nlimbs}] a
, reg u64 ap
) -> reg ptr u64[${nlimbs}]
{
  inline int i;
  reg u64 t;

  for i = 0 to ${nlimbs} {
    t = [ap + 8*i];
    a[i] = t;
  }

  return a;
}

//#[returnaddress=reg]
fn ${qual}_load
( reg mut ptr u64[${nlimbs}] a
, reg u64 ap
) -> reg ptr u64[${nlimbs}]
{
  a = ${qual}__load(a, ap);
  return a;
}

inline fn ${qual}_load_
( reg mut ptr u64[${nlimbs}] a
, reg u64 ap
) -> reg ptr u64[${nlimbs}]
{
  a = a; ap = ap;
  a = ${qual}_load(a, ap);
  a = a;
  return a;
}

/* Stores a BN into memory */
inline fn ${qual}__store
( reg u64 ap,
  reg const ptr u64[${nlimbs}] a
)
{
  inline int i;
  reg u64 t;

  for i = 0 to ${nlimbs} {
    t = a[i];
    [ap + 8*i] = t;
  }
}

fn ${qual}_store
( reg u64 ap,
  reg const ptr u64[${nlimbs}] a
) {
  ${qual}__store(ap, a);
}

inline fn ${qual}_store_
( reg u64 ap,
  reg const ptr u64[${nlimbs}] a
) {
  ap = ap; a = a;
  ${qual}__store(ap, a);
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn ${qual}__eq_zf
( reg const ptr u64[${nlimbs}] a b
) -> reg bool {
  inline int i;
  reg u64 acc t;
  reg bool zf;

  acc = 0;
  for i = 0 to ${nlimbs} {
    t = a[i];
    t ^= b[i];
    acc |= t;
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
    
  return zf;
}

fn ${qual}_eq_zf
( reg const ptr u64[${nlimbs}] a b
) -> reg bool {
  reg bool zf;
  zf = ${qual}__eq_zf(a, b);
  return zf;
}

inline fn ${qual}_eq_zf_
( reg const ptr u64[${nlimbs}] a b
) -> reg bool {
  reg bool zf;
  a = a; b = b;
  zf = ${qual}_eq_zf(a, b);
  return zf;
}

/**
 * Compares two field elements.
 * If a == b, return 1. Otherwise, return 0.
 */
inline fn ${qual}_eq_
( reg const ptr u64[${nlimbs}] a b
) -> reg u64 /* 0 or 1 */ {
  reg u64 are_equal res;
  reg bool zf;

  zf = ${qual}_eq_zf_(a, b);
  res = 0;
  are_equal = 1;
  res = are_equal if zf;
    
  return res;
}

//@ ensures res == if bn(a)=0 then 1 else 0;
inline fn ${qual}__test0_zf
( reg const ptr u64[${nlimbs}] a
) -> reg bool {
  inline int i;
  reg u64 acc;
  reg bool zf;

  acc = a[0];
  for i = 1 to ${nlimbs} {
    acc |= a[i];
  }
  (_, _, _, _, zf, _) = #AND(acc, acc);
  return zf;
}

//@ ensures \result == (bn(a)==0);
fn ${qual}_test0_zf
( reg const ptr u64[${nlimbs}] a
) -> reg bool {
  reg bool zf;
  zf = ${qual}__test0_zf(a);
  return zf;
}

inline fn ${qual}_test0_zf_
( reg const ptr u64[${nlimbs}] a
) -> reg bool {
  reg bool zf;
  a = a;
  zf = ${qual}__test0_zf(a);
  return zf;
}

//@ ensures res == if bn(a)=0 then 1 else 0;
inline fn ${qual}_test0_
( reg const ptr u64[${nlimbs}] a
) -> reg u64 {
  reg u64 is_zero res;
  reg bool zf;

  res = 0;
  is_zero = 1;    
  zf = ${qual}_test0_zf_(a);
  res = is_zero if zf;

  return res;
}

//@ ensures \result == a;
inline fn ${qual}__copy
( reg const ptr u64[${nlimbs}] a
) -> stack u64[${nlimbs}] {
  inline int i;
  reg u64 t;
  stack u64[${nlimbs}] r;
    
  for i = 0 to ${nlimbs} {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

//@ ensures \result == a;
inline fn ${qual}__mov
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;
    
  for i = 0 to ${nlimbs} {
    t = a[i];
    r[i] = t;
  }
    
  return r;
}

fn ${qual}_mov
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  r = ${qual}__mov(r, a);
  return r;
}

inline fn ${qual}_mov_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  r = r;
  a = a;
  r = ${qual}_mov(r, a);
  r = r;
  return r;
}

//@ ensures \result = if cond then b else a;
inline fn ${qual}__cmov
( reg mut ptr u64[${nlimbs}] a
, reg bool cond
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;
    
  for i = 0 to ${nlimbs} {
    t = a[i];
    t = b[i] if cond;
    a[i] = t;
  }
    
  return a;
}

fn ${qual}_cmov
( reg mut ptr u64[${nlimbs}] a
, reg bool cond
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
  a = ${qual}__cmov(a, cond, b);
  return a;
}

inline fn ${qual}_cmov_
( reg mut ptr u64[${nlimbs}] a
, reg bool cond
, reg const ptr u64[${nlimbs}] b
) -> reg ptr u64[${nlimbs}] {
  a = a;
  b = b;
  a = ${qual}_cmov(a, cond, b);
  a = a;
  return a;
}


inline fn ${qual}__cswap_mask
 ( reg mut ptr u64[${nlimbs}] x
 , reg mut ptr u64[${nlimbs}] y
 , reg u64 mask // 0/-1
 ) -> reg ptr u64[${nlimbs}] , reg ptr u64[${nlimbs}] {
  reg u64 tmp;
  inline int i;
  for i = 0 to ${nlimbs} {
   tmp   = x[i];
   tmp  ^= y[i];
   tmp  &= mask;
   x[i] ^= tmp;
   y[i] ^= tmp;
  }

  return x, y;
}

fn ${qual}_cswap_mask
 ( reg mut ptr u64[${nlimbs}] x
 , reg mut ptr u64[${nlimbs}] y
 , reg u64 mask // 0/-1
 ) -> reg ptr u64[${nlimbs}] , reg ptr u64[${nlimbs}] {
  x, y = ${qual}__cswap_mask(x,y,mask);
  return x,y;
}

inline fn ${qual}_cswap_mask_
 ( reg mut ptr u64[${nlimbs}] x
 , reg mut ptr u64[${nlimbs}] y
 , reg u64 mask // 0/-1
 ) -> reg ptr u64[${nlimbs}] , reg ptr u64[${nlimbs}] {
  x = x;
  y = y;
  x, y = ${qual}_cswap_mask(x,y,mask);
  x = x;
  y = y;
  return x, y;
}

inline fn ${qual}_cswap_cf_
 ( reg mut ptr u64[${nlimbs}] x
 , reg mut ptr u64[${nlimbs}] y
 , reg bool cf
 ) -> reg ptr u64[${nlimbs}] , reg ptr u64[${nlimbs}] {
  reg u64 mask;
  mask = ${qualUTIL}__cf_mask(cf);
  x, y = ${qual}_cswap_mask_(x, y, mask);
  return x, y;
}

//@ ensures \forall v in \result; v == 0;
inline fn ${qual}__fill
( reg mut ptr u64[${nlimbs}] a
, reg u64 x
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  for i = 0 to ${nlimbs} {
    a[i] = x;
  }
  return a;
}

fn ${qual}_fill
( reg mut ptr u64[${nlimbs}] a
, reg u64 x
) -> reg ptr u64[${nlimbs}] {
  a = ${qual}__fill(a, x);
  return a;
}

inline fn ${qual}_fill_
( reg mut ptr u64[${nlimbs}] a
, reg u64 x
) -> reg ptr u64[${nlimbs}] {
  a = a; x = x;
  a = ${qual}__fill(a, x);
  a = a;
  return a;
}

//@ ensures \forall v in \result; v == 0;
inline fn ${qual}_set0_
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  reg u64 t;
  t = 0;
  a = ${qual}_fill_(a, t);
  return a;
}

inline fn ${qual}__cfill
( reg mut ptr u64[${nlimbs}] a
, reg bool b
, reg u64 x
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;
  for i = 0 to ${nlimbs} {
    t = a[i];
    t = x if b;
    a[i] = t;
  }
  return a;
}

inline fn ${qual}__or_mask
( reg mut ptr u64[${nlimbs}] a
, reg u64 mask
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  for i = 0 to ${nlimbs} {
    a[i] |= mask;
  }
  return a;
}

fn ${qual}_or_mask
( reg mut ptr u64[${nlimbs}] a
, reg u64 mask
) -> reg ptr u64[${nlimbs}] {
  a = ${qual}__or_mask(a, mask);
  return a;
}

inline fn ${qual}_or_mask_
( reg mut ptr u64[${nlimbs}] a
, reg u64 mask
) -> reg ptr u64[${nlimbs}] {
  a = a; mask = mask;
  a = ${qual}_or_mask(a, mask);
  a = a;
  return a;
}

inline fn ${qual}_set_err_
( reg mut ptr u64[${nlimbs}] a
, stack u64 _err
) -> reg ptr u64[${nlimbs}] {
  reg u64 err;
  err = _err;
  a = ${qual}_or_mask_(a, err);
  return a;
}

inline fn ${qual}__and_mask
( reg mut ptr u64[${nlimbs}] a
, reg u64 mask
) -> reg ptr u64[${nlimbs}] {
  inline int i;
  for i = 0 to ${nlimbs} {
    a[i] &= mask;
  }
  return a;
}

fn ${qual}_and_mask
( reg mut ptr u64[${nlimbs}] a
, reg u64 mask
) -> reg ptr u64[${nlimbs}] {
  a = ${qual}__and_mask(a, mask);
  return a;
}

inline fn ${qual}_and_mask_
( reg mut ptr u64[${nlimbs}] a
, reg u64 mask
) -> reg ptr u64[${nlimbs}] {
  a = a; mask = mask;
  a = ${qual}_and_mask(a, mask);
  a = a;
  return a;
}


//@ ensures bn(\result) = a + cf*2^(64*k)
inline fn ${qual}__carrypropU
( reg mut ptr u64[${nlimbs}] a,
  reg bool cf,
  inline int k
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  for i=k to ${nlimbs}
  { cf, a[i] += 0 + cf; }

  return cf, a;
}

//@ ensures (\result)
//    = a %% 2^(64) + 2^(64) * (a %/ 2^(64) + b %/ 2^(64) + cf)
inline fn ${qual}__addc1U
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}]
{
  inline int i;
  reg u64 t;
  for i=1 to ${nlimbs} {
    t = b[i];
    cf, a[i] += t + cf;
  }

  return cf, a;
}

fn ${qual}_addc1U
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  cf, a = ${qual}__addc1U(a, b, cf);
  return cf, a;
}

inline fn ${qual}_addc1U_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  a = a; b = b;
  cf, a = ${qual}_addc1U(a, b, cf);
  a = a;
  return cf, a;
}
  
/* multi-limb addition (update inplace) */
inline fn ${qual}_addcU_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg u64 t;

  t = b[0];
  cf, a[0] += t + cf;
  cf, a = ${qual}_addc1U_(a, b, cf);
  return cf, a;
}

inline fn ${qual}_addU_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] += t;
  cf, a = ${qual}_addc1U_(a, b, cf);
  return cf, a;
}

inline fn ${qual}__addc1
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;

  for i=1 to ${nlimbs} { 
   t = a[i];
   cf, t += b[i] + cf;
   r[i] = t;
  }

  return cf, r;
}

fn ${qual}_addc1
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  cf, r = ${qual}__addc1(r, a, b, cf);
  return cf, r;
}

inline fn ${qual}_addc1_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  r = r; a = a; b = b;
  cf, r = ${qual}_addc1(r, a, b, cf);
  r = r;
  return cf, r;
}

inline fn ${qual}_add_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  reg u64 t;
  t = a[0];
  cf, t += b[0];
  r[0] = t;
  cf, r = ${qual}_addc1_(r, a, b, cf);
  return cf, a;
}

inline fn ${qual}_addc_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg u64 t;
  t = a[0];
  cf, t += b[0] + cf;
  r[0] = t;
  cf, r = ${qual}_addc1_(r, a, b, cf);
  return cf, a;
}

/* performs multi-limb subtraction */
inline fn ${qual}__subc1U
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;

  for i=1 to ${nlimbs} {
   t = b[i];
   cf, a[i] -= t - cf;
  }

  return cf, a;
}

fn ${qual}_subc1U
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
 cf, a = ${qual}__subc1U(a, b, cf);
 return cf, a;
}

inline fn ${qual}_subc1U_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  a = a; b = b;
  cf, a = ${qual}_subc1U(a, b, cf);
  a = a;
  return cf, a;
}

inline fn ${qual}_subU_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg bool cf;
  reg u64 t;

  t = b[0];
  cf, a[0] -= t;
  cf, a = ${qual}_subc1U_(a, b, cf);
  return cf, a;
}

inline fn ${qual}_subcU_
( reg mut ptr u64[${nlimbs}] a
, reg const ptr u64[${nlimbs}] b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}]
{
  reg u64 t;

  t = b[0];
  cf, a[0] -= t - cf;
  cf, a = ${qual}_subc1U_(a, b, cf);
  return cf, a;
}

inline fn ${qual}__subc1
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;

  for i=1 to ${nlimbs} {
   t = a[i];
   cf, t -= b[i] - cf;
   r[i] = t;
  }

  return cf, r;
}

fn ${qual}_subc1
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  cf, r = ${qual}__subc1(r, a, b, cf);
  return cf, r;
}

inline fn ${qual}_subc1_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  r = r; a = a; b = b;
  cf, r = ${qual}_subc1(r, a, b, cf);
  r = r;
  return cf, r;
}

inline fn ${qual}_sub_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg bool, reg ptr u64[${nlimbs}] {
  reg bool cf;
  reg u64 t;
  t = a[0];
  cf, t -= b[0];
  r[0] = t;
  cf, r = ${qual}_subc1_(r, a, b, cf);
  return cf, r;
}
 
inline fn ${qual}_subc_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  reg u64 t;
  t = a[0];
  cf, t -= b[0] - cf;
  r[0] = t;
  cf, r = ${qual}_subc1_(r, a, b, cf);
  return cf, r;
}
 

/* comparison */
inline fn ${qual}__ltc1_cf
( reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool {
  inline int i;
  reg u64 t;

  for i=1 to ${nlimbs} {
   t = a[i];
   cf, t -= b[i] - cf;
  }

  return cf;
}

fn ${qual}_ltc1_cf
( reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool {
  cf = ${qual}__ltc1_cf(a, b, cf);
  return cf;
}

inline fn ${qual}_ltc1_cf_
( reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool {
  a = a; b = b;
  cf = ${qual}_ltc1_cf(a, b, cf);
  return cf;
}

inline fn ${qual}_lt_cf_
( reg const ptr u64[${nlimbs}] a b
) -> reg bool {
  reg bool cf;
  reg u64 t;

  t = a[0];
  cf, t -= b[0];
  cf = ${qual}_ltc1_cf_(a, b, cf);
  return cf;
}

inline fn ${qual}_ltc_cf_
( reg const ptr u64[${nlimbs}] a b
, reg bool cf
) -> reg bool {
  reg u64 t;

  t = a[0];
  cf, t -= b[0] - cf;
  cf = ${qual}_ltc1_cf_(a, b, cf);
  return cf;
}

/* Negation (two's complement) */
inline fn ${qual}__negc1U
( reg mut ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;

  for i=1 to ${nlimbs} {
   t = 0;
   cf, t -= a[i] - cf;
   a[i] = t;
  }

  return cf, a;
}

fn ${qual}_negc1U
( reg mut ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  cf, a = ${qual}__negc1U(a, cf);
  return cf, a;
}

inline fn ${qual}_negc1U_
( reg mut ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  a = a;
  cf, a = ${qual}_negc1U(a, cf);
  a = a;
  return cf, a;
}

inline fn ${qual}_negU_
( reg mut ptr u64[${nlimbs}] a
) -> reg bool, reg ptr u64[${nlimbs}] {
  reg bool cf;
  reg u64 t;

  t = 0;
  cf, t -= a[0];
  a[0] = t;
  cf, a = ${qual}_negc1U_(a, cf);
  return cf, a;
}

inline fn ${qual}_negcU_
( reg mut ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  reg u64 t;

  t = 0;
  cf, t -= a[0] - cf;
  a[0] = t;
  cf, a = ${qual}_negc1U_(a, cf);
  return cf, a;
}


inline fn ${qual}__negc1
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  inline int i;
  reg u64 t;

  for i=1 to ${nlimbs} {
   t = 0;
   cf, t -= a[i] - cf;
   r[i] = t;
  }

  return cf, r;
}

fn ${qual}_negc1
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  cf, r = ${qual}__negc1(r, a, cf);
  return cf, r;
}

inline fn ${qual}_negc1_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  r = r; a = a;
  cf, r = ${qual}_negc1(r, a, cf);
  r = r;
  return cf, r;
}

inline fn ${qual}_neg_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg bool, reg ptr u64[${nlimbs}] {
  reg bool cf;
  reg u64 t;

  t = 0;
  cf, t -= a[0];
  r[0] = t;
  cf, r = ${qual}_negc1_(r, a, cf);
  return cf, r;
}

inline fn ${qual}_negc_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
, reg bool cf
) -> reg bool, reg ptr u64[${nlimbs}] {
  reg u64 t;

  t = 0;
  cf, t -= a[0] - cf;
  r[0] = t;
  cf, r = ${qual}_negc1_(r, a, cf);
  return cf, r;
}

inline fn ${qual}_cnegU_
( reg mut ptr u64[${nlimbs}] a
, reg u64 cond
) -> reg u64[${nlimbs}] {
  reg bool cf;
  stack u64[${nlimbs}] _x;
  reg ptr u64[${nlimbs}] x;
  x = _x;
  _, x = ${qual}_neg_(x, a);
  cf = ${qualUTIL}__mask_cf(cond);
  a = ${qual}_cmov_(a, cf, x);
  return a;
}


/* CONDITIONAL-ADD */
//@ ensures bn(res) == if cf then bn(x)+bn(y) else bn(x);
inline fn ${qual}_caddU_
( reg mut ptr u64[${nlimbs}] x
, reg bool cf
, reg ptr u64[${nlimbs}] y
) -> reg ptr u64[${nlimbs}]
{
  reg u64 mask;
  stack u64[${nlimbs}] _tmp;
  reg ptr u64[${nlimbs}] tmp;

  tmp = _tmp;
  tmp = ${qual}_mov_(tmp,y);
  mask = ${qualUTIL}__cf_mask(cf);
  tmp = ${qual}_and_mask_(tmp, mask);
  _, x = ${qual}_addU_(x, tmp);

  return x;
}


/* x-P if P<=x else x
   (remark: [x;lastbit] < 2*P)
 */
inline fn ${qual}_cminusP_
 ( reg mut ptr u64[${nlimbs}] x   //
 , reg const ptr u64[${nlimbs}] mP  // R-P
 , reg u64 lastbit         // 0/1
 ) -> reg ptr u64[${nlimbs}]  // [x,lastbit]<P ? x : [x,lastbit]-P
{
  reg bool _cf;
  stack u64[${nlimbs}] _tmp;
  reg ptr u64[${nlimbs}] tmp;

  tmp = _tmp;
  tmp = ${qual}_mov_(tmp, x);
  _cf, tmp = ${qual}_addU_(tmp, mP);

  _, lastbit += 0 + _cf;
  _, _cf, _, _, _, _ = #NEG(lastbit);

  x = ${qual}_cmov_(x, _cf, tmp);
  return x;
}




/* pack two bignums into a double bignum */
inline fn ${qual}__pack2
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] lo hi
) -> reg ptr u64[2*${nlimbs}]
{
  inline int i;
  reg u64 t;

  for i = 0 to ${nlimbs} {
    t = lo[i];
    r[i] = t;
  }
  for i = 0 to ${nlimbs} {
    t = hi[i];
    r[${nlimbs}+i] = t;
  }

  return r;
}

fn ${qual}_pack2
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] lo hi
) -> reg ptr u64[2*${nlimbs}] {
  r = ${qual}__pack2(r, lo, hi);
  return r;
}

inline fn ${qual}_pack2_
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] lo hi
) -> reg ptr u64[2*${nlimbs}] {
  r = r; lo = lo; hi = hi;
  r = ${qual}__pack2(r, lo, hi);
  r = r;
  return r;
}
