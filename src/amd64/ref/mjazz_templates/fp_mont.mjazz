/* (emulation of https://github.com/jasmin-lang/jasmin/issues/519)


modsignature {
  int nlimbs;		// num. limbs
  u64[nlimbs] glob_P;	// modulus (M)
  u64[nlimbs] glob_mP;	// minus M (2^(nlimbs*64) - M )
  u64 glob_P0i;		// inverse of M[0]
  u64[nlimbs] glob_Pm2;	// P-2
  u64[nlimbs] glob_exp0;// OneM
  u64[nlimbs] glob_RM;	// RM  
}


require "bn_base" as "BN" // BN
 with { nlimbs = NLIMBS; }
*/

from MJazz require "${qualBN}_bn_base.jinc"

// regs: params(2) + call(3) + 4 = 9
fn ${qual}_redM
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[2*${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  stack u64 _P0i;
  _P0i = ${glob_P0i};
  r = ${qualBN}__mont_redM(r, a, ${glob_P}, ${glob_mP}, _P0i);
  return r;
}

inline fn ${qual}_redM_
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[2*${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  r = r; a = a;
  r = ${qual}_redM( r, a);
  r = r;
  return r;
}

/* Conversion-out from Montgomery form */
inline fn ${qual}_fromM_
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  stack u64[2*${nlimbs}] _tmp;
  reg ptr u64[2*${nlimbs}] tmp;
  reg ptr u64[${nlimbs}] tmp2;
  reg u64 t;
  inline int i;

  tmp2 = _tmp[0:${nlimbs}];
  tmp2 = ${qualBN}_mov_(tmp2, a);
  _tmp[0:${nlimbs}] = tmp2;
  tmp2 = _tmp[${nlimbs}:${nlimbs}];
  tmp2 = ${qualBN}_set0_(tmp2);
  _tmp[${nlimbs}:${nlimbs}] = tmp2;
  tmp = _tmp;
  a = ${qual}_redM_(a, tmp);
  return a;
}


/*
require "fp_base" as "FPM"
 with { nlimbs = NLIMBS;
        glob_exp0 = glob_exp0;
        glob_Pm2 = glob_Pm2;
	fun_red = FPM_redM;
      }

*/

from MJazz require "${qualFP}_fp_base.jinc"

// ////////////////////////////////////

/* Conversion into Montgomery form */
inline fn ${qual}_toM_
( reg mut ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}] {
  reg ptr u64[${nlimbs}] rMP;
  rMP = ${glob_rMP};
  a = ${qualFP}_mulmU_(a, rMP);
  a = a;
  return a;
}

