/* This file is indeed a template for a pyhton prototype
   intended to emulate and exercise the "Parametric Modules"
   feature propose in https://github.com/jasmin-lang/jasmin/issues/519.

BN_MUL_FNS = 

*/




//modsignature { param int ${nlimbs}; }


//from Libjbn require "bn_util.mjazz"
require "${qualUTIL}_bn_util.jinc"


//from Libjbn require "bn_base.mjazz"
//. with { nlimbs = nlimbs; }
require "${qualBN}_bn_base.jinc"


/******************************************************************
                      OPERAND-SCANNING
*******************************************************************/
inline fn ${qual}__mul1
( reg mut ptr u64[2*${nlimbs}] r
, reg u64 a
, reg const ptr u64[${nlimbs}] b
) -> reg u64, reg bool, reg bool, reg u64[2*${nlimbs}]
{
  inline int i;
  reg bool of, cf;
  reg u64 _zero, lo;
  reg u64[${nlimbs}+1] rr; // at most 2 alive

  of, cf, _, _, _, _zero = #set0();

  rr[1], rr[0] = #MULX ( a, b[0] );
  r[0] = rr[0]; // kill rr[0]
  for i = 1 to ${nlimbs} {
    rr[i+1], lo = #MULX ( a, b[i] );
    cf, rr[i] = #ADCX ( rr[i], lo, cf );
    r[i] = rr[i]; // kill rr[i]
  }

  cf, rr[${nlimbs}] = #ADCX ( rr[${nlimbs}], _zero, cf );
  r[${nlimbs}] = rr[${nlimbs}];
  // cf = 0

  return _zero, of, cf, r;
}


/* multiplies a (shifted) scalar by a reg array (remaining iterations of mul) */
/* REGS (params + workspace):  */
inline fn ${qual}__mul1acc
( inline int k
, reg mut ptr u64[2*${nlimbs}] r
, reg u64 a
, reg const ptr u64[${nlimbs}] b
, reg u64 _zero // should be set to 0
, reg bool of cf // should be set to 0
) -> reg u64, reg bool, reg bool, reg u64[2*${nlimbs}]
{
  inline int i;
  reg u64 hi lo;
  reg u64[${nlimbs}+1] rr; // at most 2 alive

  rr[0] = r[k];
  for i = 0 to ${nlimbs}-1 {
    rr[i+1] = r[k+i+1];
    hi, lo = #MULX ( a, b[i] ); 
    of, rr[i] = #ADOX ( rr[i], lo, of );
    r[k+i] = rr[i]; // kill rr[i]
    cf, rr[i+1] = #ADCX ( rr[i+1], hi, cf );
  }

  rr[${nlimbs}], lo = #MULX ( a, b[${nlimbs}-1] ); // a is now dead!
  of, rr[${nlimbs}-1] = #ADOX ( rr[${nlimbs}-1], lo, of );
  r[k+${nlimbs}-1] = rr[${nlimbs}-1]; // kill rr[${nlimbs}-1]

  cf, rr[${nlimbs}] = #ADCX ( rr[${nlimbs}], _zero, cf);
  of, rr[${nlimbs}] = #ADOX ( rr[${nlimbs}], _zero, of);
  r[k+${nlimbs}] = rr[${nlimbs}];
  // cf = 0, of = 0

  return _zero, of, cf, r;
}


/* Operand-scanning multiplication (first arg. as a reg_ptr) */
fn ${qual}_os_muln
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b //reg u64 fptr,
) -> reg ptr u64[2*${nlimbs}]
{
  inline int i;
  reg bool of cf;
  reg u64 _zero ai;

  ai = a[0];

  _zero, of, cf, r = ${qual}__mul1(r, ai, b);

  for i = 1 to ${nlimbs} {
    ai = a[i];
    _zero, of, cf, r = ${qual}__mul1acc(i, r, ai, b, _zero, of, cf);
  }

  return r;
}

inline fn ${qual}_os_muln_
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg ptr u64[2*${nlimbs}]
{
  r = r; a = a; b = b;
  r = ${qual}_os_muln(r, a, b);
  r = r;
  return r;
}


/*
export fn bn_muln_os(reg u64 rp ap bp)
{
  stack u64[${nlimbs}] _a _b;
  stack u64[2*${nlimbs}] _r;
  reg ptr u64[${nlimbs}] a b;
  reg ptr u64[2*${nlimbs}] r;

  a = _a;
  a = __load(a,ap);
  b = _b;
  b = __load(b,bp);
  r = _r;
  r = _muln_os_(r, a, b);
  __store2(rp, r);
}
*/

/******************************************************************
                      PRODUCT-SCANNING
*******************************************************************/


// regs: params(5) + 3 = 8
inline fn ${qual}__muln_innerloop
( reg u64[3] x
, inline int k istart iend
, reg ptr u64[${nlimbs}] a b
) -> reg u64[3] {
  reg u64 t1, t0;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    t0 = a[i];
    t1, t0 = t0 * b[j];
    x = ${qualUTIL}__addacc3(x, t1, t0, k);
  }
  return x;
}

// regs: params(3) + call(3) + 3(+2) = 9
inline fn ${qual}__ps_muln
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg ptr u64[2*${nlimbs}] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;

  t0 = a[0];
  t1, t0 = t0 * b[0];
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
  for k = 1 to ${nlimbs} {
    x = ${qual}__muln_innerloop(x, k, 0, k+1, a, b);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = ${nlimbs} to 2*${nlimbs}-1 {
    x = ${qual}__muln_innerloop(x, k, k-${nlimbs}+1, ${nlimbs}, a, b);
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*${nlimbs}-1] = x[(2*${nlimbs}-1) % 3];
  return r;
}

// regs: params(3) + call(6) = 9
fn ${qual}_ps_muln
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg ptr u64[2*${nlimbs}] {
  r = ${qual}__ps_muln(r, a, b);
  return r;
}

inline fn ${qual}_ps_muln_
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a b
) -> reg ptr u64[2*${nlimbs}] {
  r = r; a = a; b = b;
  r = ${qual}_ps_muln(r, a, b);
  r = r;
  return r;
}

/*
export fn ${qual}bn_ps_muln(reg u64 rp ap bp)
{
  stack u64[${nlimbs}] _a _b;
  stack u64[2*${nlimbs}] _r;
  reg ptr u64[${nlimbs}] a b;
  reg ptr u64[2*${nlimbs}] r;

  a = _a;
  a = ${qual}__load(a,ap);
  b = _b;
  b = ${qual}__load(b,bp);
  r = _r;
  r = ${qual}_ps_muln_(r, a, b);
  ${qual}__store2(rp, r);
}
*/


// regs: params(4) + 2 = 6 
inline fn ${qual}__sqrn_innerloop
( reg u64[3] x
, inline int k istart iend
, reg const ptr u64[${nlimbs}] a
) -> reg u64[3] {
  reg u64 ti, tj;
  inline int i, j;
  for i = istart to iend {
    j = k-i;
    ti = a[i];
    tj = a[j];
    x = ${qualUTIL}__addacc3x2(x, ti, tj, k);
  }
  return x;
}

inline fn ${qual}__ps_sqrn
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[2*${nlimbs}] {
  inline int k;
  reg u64 t0 t1;
  reg u64[3] x;

  t0 = a[0];
  t1, t0 = t0 * t0;
  r[0] = t0;
  x[1] = t1;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;
//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;

  for k = 1 to ${nlimbs} {
    x = ${qual}__sqrn_innerloop(x, k, 0, (k+1)/2, a);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = ${qualUTIL}__addacc3(x, t1, t0, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  for k = ${nlimbs} to 2*${nlimbs}-1 {
    x = ${qual}__sqrn_innerloop(x, k, k-${nlimbs}+1, (k+1)/2, a);
    if (k % 2 == 0) {
      t0 = a[k/2];
      t1, t0 = t0 * t0;
      x = ${qualUTIL}__addacc3(x, t1, t0, k);
    }
    t0 = x[k % 3];
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
    r[k] = t0;
  }
  r[2*${nlimbs}-1] = x[(2*${nlimbs}-1) % 3];
  return r;
}

fn ${qual}_ps_sqrn
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[2*${nlimbs}] {
  r = ${qual}__ps_sqrn(r, a);
  return r;
}

inline fn ${qual}_ps_sqrn_
( reg mut ptr u64[2*${nlimbs}] r
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[2*${nlimbs}] {
  r = r; a = a;
  r = ${qual}_ps_sqrn(r, a);
  r = r;
  return r;
}

inline fn ${qual}_ps_ksqrn_
( reg mut ptr u64[2*${nlimbs}] r
, reg mut ptr u64[${nlimbs}] tmp
, reg const ptr u64[${nlimbs}] a
) -> reg ptr u64[${nlimbs}], reg ptr u64[2*${nlimbs}]
{
  r = ${qual}_ps_sqrn_( r, a );
  return tmp, r;
}




// ////////////////////////////////////
// regs: params(3) + call(3) + 3 = 9
inline fn ${qual}__mont_redM
( reg mut ptr u64[${nlimbs}] r
, reg const ptr u64[2*${nlimbs}] a
, stack u64[${nlimbs}] _P
, stack u64[${nlimbs}] _mP
, stack u64 _U0
) -> reg ptr u64[${nlimbs}] {
  inline int k;
  reg bool cf;
  reg ptr u64[${nlimbs}] P mP;
  reg u64 t0 t1 zero lastbit;
  reg u64[3] x;

//  _, _, _, _, _, x[0] = #set0();
  x[0] = 0;
//  _, _, _, _, _, x[1] = #set0();
  x[1] = 0;
//  _, _, _, _, _, x[2] = #set0();
  x[2] = 0;

  for k = 0 to ${nlimbs} {
    P = _P;
    x = ${qual}__muln_innerloop(x, k, 0, k, r, P); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = ${qualUTIL}__addacc3(x, zero, t0, k);
    t0 = x[k % 3];
    _, t0 = t0 * _U0;
    r[k] = t0;
    t1, t0 = t0 * _P[0];
    x = ${qualUTIL}__addacc3(x, t1, t0, k);
  }
  for k = ${nlimbs} to 2*${nlimbs}-1 {
    P = _P;
    x = ${qual}__muln_innerloop(x, k, k-${nlimbs}+1, ${nlimbs}, r, P); //+3
//    _, _, _, _, _, zero = #set0();
    zero = 0;
    t0 = a[k];
    x = ${qualUTIL}__addacc3(x, zero, t0, k);
    t0 = x[k % 3];
    r[k-${nlimbs}] = t0;
//    _, _, _, _, _, x[k % 3] = #set0();
    x[k % 3] = 0;
  }

  lastbit = 0;
  cf, x[(2*${nlimbs}-1) % 3] += a[2*${nlimbs}-1];
  _, lastbit += 0 + cf;

  r[${nlimbs}-1] = x[(2*${nlimbs}-1) % 3];

  mP = _mP;
  r = ${qualBN}_cminusP_(r, mP, lastbit);
  return r;
}


